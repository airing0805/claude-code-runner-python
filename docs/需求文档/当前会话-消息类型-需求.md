## 1. 消息类型定义

| 类型 | 说明 | 样式 |
|------|------|------|
| text | 文本内容 | 蓝色边框 |
| thinking | 思考过程 (v0.2.11+) | 黄色背景，可折叠 |
| tool_use | 工具调用 | 绿色边框 |
| tool_result | 工具结果 | 蓝色边框 |
| error | 错误信息 | 红色边框 |
| complete | 任务完成 | 蓝色边框 |
| info | 提示信息 | 天蓝色边框 |
| ask_user_question | 用户问答 (v0.x.x+) | 紫色边框，交互式选项 |

## 2. 用户问答消息 (ask_user_question)

### 2.1 功能概述

当 Claude Code 在执行任务过程中需要用户确认、选择或输入信息时，会暂停执行并向用户提问。用户回答后，任务继续执行。

**使用场景：**
- 需要用户确认操作（如：是否删除文件）
- 需要用户选择选项（如：选择 A/B/C 方案）
- 需要用户提供额外信息（如：输入配置参数）
- **多轮对话体验**（如：连续发起多个问答来演示功能）

### 2.2 多轮对话业务规则

#### 2.2.1 递归对话支持
```
业务规则：
- 允许在同一会话中连续发起多个AskUserQuestion
- 每个问答实例保持独立的状态管理
- 通过消息链(parentUuid)维护对话顺序
- 支持用户选择"再给一个多选框"等元选项

典型场景：
用户连续选择"再给一个多选框还是这些选项"来体验多轮对话过程
系统应正确处理此类递归行为，不视为异常
```

#### 2.2.2 对话状态管理
```
状态流转：
pending(等待回答) → answered(已回答) → [继续下一个问答或执行最终操作]

并发控制：
- 同一会话内可存在多个pending状态的问答
- 按消息链顺序依次处理
- 支持问答间的条件依赖关系
```

### 2.3 消息数据结构

#### 2.3.1 工具调用（Claude → 用户）

`AskUserQuestion` 在会话中作为**工具调用**（`tool_use`）执行，完整的消息结构如下：

```json
{
  "type": "message",
  "role": "assistant",
  "content": [
    {
      "type": "tool_use",
      "id": "call_function_8kherxj202p7_1",
      "name": "ask_user_question",
      "input": {
        "questions": [
          {
            "header": "选择功能",
            "multiSelect": true,
            "options": [
              {
                "description": "背诵一首经典唐诗",
                "label": "背唐诗"
              },
              {
                "description": "讲一个有趣的笑话",
                "label": "讲笑话"
              },
              {
                "description": "输出一个笑脸表情",
                "label": "输出笑脸图标"
              }
            ],
            "question": "请选择一个功能"
          }
        ]
      }
    }
  ]
}
```

#### 2.3.2 工具结果（用户 → Claude）

用户作答后，通过 `tool_result` 返回答案：

```json
{
  "type": "message",
  "role": "user",
  "content": [
    {
      "type": "tool_result",
      "content": "User has answered your questions: \"请选择一个功能\"=\"再给一个多选框还是这些选项（我想了解多次对话这个过程）\". You can now continue with the user's answers in mind.",
      "tool_use_id": "call_function_8kherxj202p7_1"
    }
  ]
}
```

#### 2.3.3 完整会话消息链（JSONL 格式）

```
{"type": "user", "message": {"role": "user", "content": [{"type": "text", "text": "使用ask_user_question工具，给我弹一个多选对话框..."}], "uuid": "msg_001", "parentUuid": null}
{"type": "assistant", "message": {"role": "assistant", "content": [{"type": "tool_use", "id": "call_function_8kherxj202p7_1", "name": "AskUserQuestion", "input": {...}}]}, "uuid": "msg_002", "parentUuid": "msg_001"}
{"type": "user", "message": {"role": "user", "content": [{"type": "tool_result", "tool_use_id": "call_function_8kherxj202p7_1", "content": "...再给一个多选框..."}]}, "uuid": "msg_003", "parentUuid": "msg_002", "toolUseResult": {...}}
{"type": "assistant", "message": {"role": "assistant", "content": [{"type": "text", "text": "好的，你选择了第二个选项。让我再弹出一个同样的多选对话框。"}]}, "uuid": "msg_004", "parentUuid": "msg_003"}
{"type": "assistant", "message": {"role": "assistant", "content": [{"type": "tool_use", "id": "call_function_nkxnxhd9vtmk_1", "name": "AskUserQuestion", "input": {...}}]}, "uuid": "msg_005", "parentUuid": "msg_004"}
```

#### 2.3.4 简化的问答消息结构（API 推送格式）

在实际 API 推送中，可以简化外层包装，直接传递问题内容：

```
{
  "type": "ask_user_question",
  "question": {
    "question_id": "auth_strategy_01",
    "header": "确认操作",
    "question_text": "确定要删除以下文件吗？",
    "description": "请确认是否删除，这些操作不可撤销。",
    "type": "multiple_choice",
    "options": [
      {
        "id": "option_a",
        "label": "选项 A",
        "description": "选项 A 的描述说明",
        "default": false
      },
      {
        "id": "option_b",
        "label": "选项 B",
        "description": "选项 B 的描述说明",
        "default": true
      }
    ],
    "required": true,
    "follow_up_questions": {
      "oauth2": [
        {
          "question_id": "oauth_providers",
          "question_text": "请选择要集成的 OAuth 提供商：",
          "type": "checkbox",
          "options": [
            { "id": "google", "label": "Google" },
            { "id": "github", "label": "GitHub" }
          ]
        }
      ]
    }
  },
  "tool_use_id": "toolu_xxx",
  "timestamp": "2026-02-19T10:00:00.000Z"
}
```

### 2.4 数据字段说明

#### 2.4.1 工具调用层字段（tool_use）

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| type | string | 是 | 固定为 "tool_use" |
| id | string | 是 | 工具调用唯一标识，用于关联 tool_result |
| name | string | 是 | 固定为 "ask_user_question" |
| input | object | 是 | 问题数据对象，包含所有问题内容 |

#### 2.4.2 问题输入字段（input/questions）

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| questions | array | 是 | 问题数组，支持单个或多个问题 |
| questions[].header | string | 否 | 问题标题/标签（建议最多12字符） |
| questions[].question | string | 是 | 向用户显示的核心问题文本 |
| questions[].multiSelect | boolean | 否 | 是否支持多选，默认false |
| questions[].options | array | 是 | 选项数组 |
| questions[].options[].label | string | 是 | 用户可见文本 |
| questions[].options[].description | string | 否 | 选项详细说明 |

#### 2.4.3 工具结果字段（tool_result）

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| type | string | 是 | 固定为 "tool_result" |
| tool_use_id | string | 是 | 对应 tool_use 的 id，用于关联问答 |
| content | string | 是 | 用户答案的描述性文本 |

### 2.5 多轮对话特殊处理

#### 2.5.1 元选项识别
```
特殊选项："再给一个多选框还是这些选项（我想了解多次对话这个过程）"
处理规则：
- 识别为用户想要体验多轮对话的行为
- 系统应正常响应并发起新的问答
- 不应视为错误输入或异常情况
- 保持对话的自然流畅性
```

#### 2.5.2 递归深度控制
```
控制机制：
- 设置合理的递归深度限制（建议10层）
- 超过限制时给出友好提示
- 提供退出机制让用户体验完整流程
```

### 2.6 前端交互设计

#### 2.6.1 多轮对话显示
```
显示要求：
- 清晰标识当前是第几轮对话
- 保留历史问答记录供参考
- 提供对话进度指示器
- 支持用户随时查看之前的选项
```

#### 2.6.2 问答消息显示

```
┌─────────────────────────────────────────────────────────┐
│  💬 第1轮选择功能                                       │
├─────────────────────────────────────────────────────────┤
│  请选择一个功能                                          │
│                                                         │
│  ┌─────────────────────────────────────────────────┐  │
│  │ ☑ 背唐诗 - 背诵一首经典唐诗                      │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ ○ 讲笑话 - 讲一个有趣的笑话                      │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ ○ 输出笑脸图标 - 输出一个笑脸表情                 │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ ○ 再给一个多选框 - 继续体验多轮对话               │  │
│  └─────────────────────────────────────────────────┘  │
│                                                         │
│  ┌──────────────────────┐  ┌──────────────────────┐  │
│  │        取消          │  │        确认          │  │
│  └──────────────────────┘  └──────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

#### 2.6.3 选项类型

| 类型 | 说明 | 交互方式 |
|------|------|----------|
| multiple_choice | 单选，用户选择一个选项 | 圆形单选按钮 |
| checkbox | 多选，用户选择多个选项 | 方形复选框 |
| text | 自由文本输入 | 文本输入框 |
| boolean | 是/否选择 | 开关或单选按钮 |

#### 2.6.4 条件追问 (follow_up_questions)

当用户选择特定选项后，可触发追问问题：

```
用户选择 "OAuth 2.0" 后：
┌─────────────────────────────────────────────────────────┐
│  请选择要集成的 OAuth 提供商：                            │
│                                                         │
│  ☐ Google                                              │
│  ☑ GitHub                                              │
│  ☐ Microsoft                                           │
└─────────────────────────────────────────────────────────┘
```

#### 2.6.5 用户操作

| 操作 | 触发方式 | 响应 |
|------|----------|------|
| 选择选项 | 点击选项 | 高亮选中，可多选 |
| 提交回答 | 点击"确认"按钮 | 发送回答给后端，任务继续执行 |
| 取消问答 | 点击"取消"按钮 | 发送空回答或取消信号，任务可能终止 |
| 任务继续 | 后端收到回答 | 恢复任务执行，显示后续输出 |

### 2.7 后端 API 设计

#### 2.7.1 多轮对话状态管理

```json
{
  "session_id": "session_xxx",
  "current_round": 3,
  "total_rounds": 5,
  "dialog_history": [
    {
      "round": 1,
      "question": "请选择一个功能",
      "answer": "再给一个多选框还是这些选项"
    },
    {
      "round": 2,
      "question": "请再次选择一个功能", 
      "answer": "再给一个多选框还是这些选项"
    }
  ]
}
```

#### 2.7.2 会话恢复支持
```
恢复机制：
- 通过sessionId恢复中断的多轮对话
- 保持完整的对话历史记录
- 支持从任意轮次继续对话
```

```
POST /api/task/answer
Content-Type: application/json

{
  "session_id": "session_xxx",
  "question_id": "auth_strategy_01",
  "answer": "option_a"
}
```

**多选回答格式：**
```
{
  "session_id": "session_xxx",
  "question_id": "oauth_providers",
  "answer": ["google", "github"]
}
```

**文本输入回答格式：**
```
{
  "session_id": "session_xxx",
  "question_id": "custom_port",
  "answer": "8080"
}
```

#### 2.7.3 回答响应

```
{
  "success": true,
  "message": "答案已提交，任务继续执行"
}
```

### 2.8 状态管理

| 状态 | 说明 | 多轮对话特殊考虑 |
|------|------|----------------|
| pending | 等待用户回答 | 支持同会话多个pending状态 |
| answered | 用户已回答 | 记录回答历史，支持回溯 |
| cancelled | 用户取消问答 | 提供取消原因，支持优雅退出 |
| timeout | 问答超时 | 超时后可选择恢复或终止 |

### 2.9 错误处理

| 错误类型 | HTTP 状态码 | 说明 | 多轮对话处理 |
|----------|-------------|------|-------------|
| session_not_found | 404 | 会话不存在 | 检查会话是否过期 |
| question_not_found | 404 | 问题不存在 | 可能是多轮对话中的旧问题 |
| invalid_answer | 400 | 答案格式无效 | 提供具体的格式要求 |
| recursive_limit_exceeded | 429 | 递归深度超限 | 建议用户完成当前对话 |

### 2.10 多环境适配

#### 2.10.1 Web 界面增强

针对多轮对话的特殊支持：
- **对话历史面板**：显示已完成的问答轮次
- **进度指示器**：显示当前对话进度
- **上下文回顾**：允许用户查看之前的选项和回答
- **批量操作**：支持一次性处理多个相似问答

#### 2.10.2 CLI 界面适配

```
多轮对话CLI显示：
Round 1/3: 请选择一个功能
1) 背唐诗 - 背诵一首经典唐诗
2) 讲笑话 - 讲一个有趣的笑话  
3) 输出笑脸图标 - 输出一个笑脸表情
4) 再给一个多选框 - 继续体验多轮对话

> 4

Round 2/3: 请再次选择一个功能
[显示相同选项...]

> 1

正在执行：背诵唐诗...
```

#### 2.10.3 MCP（Model Context Protocol）

通过标准工具调用格式传输：

```
{
  "name": "ask_user_question",
  "input": {
    "question_id": "auth_strategy_01",
    "question_text": "您希望采用哪种身份验证策略？",
    "type": "multiple_choice",
    "options": [...]
  }
}
```

MCP 服务器负责渲染 UI 并返回用户输入。

### 2.11 开发者自定义扩展

用户可通过以下方式扩展：

- 在 `.claude/skills/` 中定义包含 `ask_user_question` 的 Skill
- 通过 MCP 实现自定义 UI（如 Web 表单、移动端弹窗）
- 在 Web 界面中通过 `/api/task/answer` 接口提交用户答案

## 3. 历史消息渲染 (v0.2.11+)

- 支持多轮对话显示，每轮包含用户输入和 AI 响应
- 按轮次分组显示，每轮显示轮次编号
- 工具调用显示工具名称和参数
- 工具结果可区分成功/错误状态
- 思考过程默认折叠，点击可展开

## 4. 业务规则

### 4.1 问答生命周期规则

| 规则 | 说明 |
|------|------|
| **生命周期** | 问答消息发出 → 用户回答/取消 → 任务继续/终止 |
| **阻塞执行** | 问答消息会阻塞 Claude Code 执行，直至用户回答 |
| **状态追溯** | 每条问答有唯一 question_id，支持审计和断点续传 |
| **超时机制** | 可配置超时时间，超时后选择默认选项或终止任务 |

### 4.2 数据格式规则

#### 4.2.1 问题定义规则

```
问题输入格式：
- question_id: 同一会话内必须唯一
- question_text: 用户可见问题文本，必填
- type: 必填，决定交互形式
- options: 选择类问题必填，至少1个选项
```

```
选项定义规则：
- id: 机器可读标识符，同一问题内唯一
- label: 用户可见文本，必填
- description: 可选，用于详细说明
- default: 可选，默认选中的选项
```

#### 4.2.2 答案格式规则

```
答案格式由问题类型决定：
- multiple_choice: 答案 = "选项id" (字符串)
- checkbox: 答案 = ["选项id1", "选项id2"] (字符串数组)
- text: 答案 = "用户输入文本" (字符串)
- boolean: 答案 = true/false (布尔值)
```

### 4.3 条件追问规则 (follow_up_questions)

| 规则 | 说明 |
|------|------|
| **触发条件** | 用户选择特定选项后自动显示追问 |
| **嵌套层级** | 支持多级追问（父问题 → 子问题 → 孙问题） |
| **答案关联** | 追问答案与父问题答案一起提交给 Claude |
| **动态显示** | 根据用户选择的父选项动态渲染相关子问题 |

**追问结构示例：**
```json
"follow_up_questions": {
  "oauth2": [          // 当用户选择 oauth2 时触发
    {
      "question_id": "oauth_providers",
      "question_text": "请选择 OAuth 提供商",
      "type": "checkbox",
      "options": [...]
    }
  ]
}
```

### 4.4 数据一致性规则

| 规则 | 约束 | 违反处理 |
|------|------|----------|
| ID 唯一性 | 同一会话内 question_id 不可重复 | 返回 400 错误 |
| 选项非空 | 选择类问题 options 至少1项 | 返回 400 错误 |
| 答案有效性 | 答案值必须在选项范围内 | 返回 400 错误 |
| 必答约束 | required=true 时必须回答 | 超时终止任务 |
| 会话绑定 | 答案必须关联正确的 session_id | 返回 404 错误 |

### 4.5 安全性规则

| 规则 | 具体约束 |
|------|----------|
| **输入过滤** | text 类型输入需过滤危险字符，防止 XSS |
| **长度限制** | 单选答案 ≤ 256 字符，多选答案 ≤ 1000 字符 |
| **会话验证** | 验证 session_id 有效性，防止跨会话攻击 |
| **防重放** | 同一 question_id 只能回答一次，重复提交返回 400 |

### 4.6 多环境适配规则

| 环境 | 适配规则 |
|------|----------|
| **CLI** | 渲染为带编号列表，支持箭头键导航和回车确认 |
| **Web** | 渲染为交互式表单组件，显示确认/取消按钮 |
| **MCP** | 通过标准工具调用传输，MCP 服务器负责渲染 UI |

### 4.7 开发者扩展规则

| 扩展方式 | 适用范围 |
|----------|----------|
| **Skill 定义** | 在 `.claude/skills/` 中预定义问答模板 |
| **MCP 扩展** | 自定义 UI 渲染逻辑（Web表单、移动端弹窗） |
| **API 动态配置** | 通过 API 动态传入问答配置 |

---

## 5. 设计原则（参考）

> 以下内容来自 Anthropic 官方 AskUserQuestion 设计规范，供理解设计意图参考。

### 5.1 核心设计原则

1. **结构化优于自由文本**
   - 强制使用 `id` 而非自然语言答案，便于程序解析
   - 所有选项必须包含机器可读的唯一标识符

2. **渐进式披露**
   - 通过 `follow_up_questions` 避免一次性抛出过多问题
   - 根据用户选择的父选项动态显示相关子问题

3. **上下文感知**
   - 问题内容可引用当前项目文件
   - 支持基于项目状态动态生成问题内容

4. **可追溯性**
   - 每个 `question_id` 对应一个决策点，便于审计和回滚
   - 支持断点续传

5. **会话关联**
   - 通过 `tool_use_id` 关联问答与答案，保持会话消息链完整
   - 问题和答案作为独立消息存在于会话历史中


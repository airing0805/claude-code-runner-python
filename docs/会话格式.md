# Claude Code 会话历史记录格式

本文档详细描述 Claude Code 的会话历史记录文件格式，方便开发者理解和解析这些数据。

## 存储位置

### 目录结构

```
~/.claude/
├── projects/                              # 所有项目的历史记录
│   ├── {encoded-project-path-1}/          # 项目目录（路径编码后的名称）
│   │   ├── {session-id-1}.jsonl           # 会话文件
│   │   ├── {session-id-2}.jsonl
│   │   └── subagents/                     # 子代理会话（可选）
│   │       └── agent-{id}.jsonl
│   └── {encoded-project-path-2}/
│       └── ...
```

### 项目目录命名规则

Claude Code 将项目路径编码为目录名：

| 操作系统 | 原始路径 | 编码后目录名 |
|---------|---------|-------------|
| Windows | `E:\workspaces\project` | `E--workspaces-project` |
| Windows | `C:\Users\admin\code` | `C--Users-admin-code` |
| Unix | `/home/user/project` | `-home-user-project` |

**编码规则**：
- Windows 盘符 `C:` → `C--`
- 路径分隔符 `\` 或 `/` → `-`

## 会话文件格式

### 文件命名

- **格式**: `{sessionId}.jsonl`
- **sessionId**: UUID 格式，如 `c102b7ad-6e4b-4c03-b5da-21cfba48f81f`

### JSONL 格式

每行是一个独立的 JSON 对象，记录一条消息或操作。

```jsonl
{"type":"queue-operation","operation":"dequeue",...}
{"type":"file-history-snapshot","messageId":"xxx",...}
{"type":"user","uuid":"xxx","message":{...},...}
{"type":"assistant","uuid":"xxx","message":{...},...}
```

## 消息类型

### 1. queue-operation（队列操作）

会话开始时的队列状态记录。

```json
{
  "type": "queue-operation",
  "operation": "dequeue",           // 操作类型：dequeue（出队）
  "timestamp": "2026-02-18T02:00:41.425Z",
  "sessionId": "c102b7ad-6e4b-4c03-b5da-21cfba48f81f"
}
```

**字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"queue-operation"` |
| `operation` | string | 操作类型，通常为 `"dequeue"` |
| `timestamp` | string | ISO 8601 时间戳 |
| `sessionId` | string | 会话唯一标识 |

---

### 2. file-history-snapshot（文件历史快照）

记录会话开始时的文件状态，用于支持撤销功能。

```json
{
  "type": "file-history-snapshot",
  "messageId": "3e118c31-1391-484a-8ca8-50a386712358",
  "snapshot": {
    "messageId": "3e118c31-1391-484a-8ca8-50a386712358",
    "trackedFileBackups": {},        // 跟踪的文件备份
    "timestamp": "2026-02-18T02:00:41.493Z"
  },
  "isSnapshotUpdate": false          // 是否为增量更新
}
```

**字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"file-history-snapshot"` |
| `messageId` | string | 关联的消息 UUID |
| `snapshot` | object | 快照数据 |
| `snapshot.messageId` | string | 关联的消息 UUID |
| `snapshot.trackedFileBackups` | object | 文件备份映射 |
| `snapshot.timestamp` | string | 快照时间戳 |
| `isSnapshotUpdate` | boolean | 是否为增量更新 |

---

### 3. user（用户消息）

用户发送的消息，包括初始输入和工具调用结果。

#### 3.1 初始用户消息

```json
{
  "parentUuid": null,                // 父消息 UUID（首条为 null）
  "isSidechain": false,              // 是否为侧边栏对话
  "userType": "external",            // 用户类型
  "cwd": "e:\\workspaces_2026_python\\claude-code-runner",  // 工作目录
  "sessionId": "c102b7ad-6e4b-4c03-b5da-21cfba48f81f",
  "version": "2.1.45",               // Claude Code 版本
  "gitBranch": "master",             // 当前 Git 分支
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "帮我分析这个项目的结构"
      }
    ]
  },
  "uuid": "3e118c31-1391-484a-8ca8-50a386712358",
  "timestamp": "2026-02-18T02:00:41.489Z",
  "permissionMode": "acceptEdits"    // 权限模式
}
```

#### 3.2 工具调用结果消息

```json
{
  "parentUuid": "0ec933d0-2a8d-4bd1-bed2-c964d008f737",
  "isSidechain": false,
  "userType": "external",
  "cwd": "e:\\workspaces_2026_python\\claude-code-runner",
  "sessionId": "c102b7ad-6e4b-4c03-b5da-21cfba48f81f",
  "version": "2.1.45",
  "gitBranch": "master",
  "slug": "deep-dazzling-harbor",    // 消息短标签
  "type": "user",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "tool_result",
        "tool_use_id": "call_33f4a566fb7e425a9f6327b4",
        "content": "文件内容...",
        "is_error": false
      }
    ]
  },
  "uuid": "2beb6ce2-d178-4d77-be9c-3206476241e5",
  "timestamp": "2026-02-18T02:01:05.968Z",
  "toolUseResult": {                 // 工具结果（旧格式）
    "type": "file",
    "file": "..."
  },
  "sourceToolAssistantUUID": "0ec933d0-2a8d-4bd1-bed2-c964d008f737"
}
```

**顶层字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"user"` |
| `uuid` | string | 消息唯一标识 (UUID) |
| `parentUuid` | string \| null | 父消息 UUID，用于构建消息链 |
| `sessionId` | string | 会话唯一标识 |
| `timestamp` | string | ISO 8601 时间戳 |
| `cwd` | string | 当前工作目录 |
| `version` | string | Claude Code 版本号 |
| `gitBranch` | string | 当前 Git 分支名 |
| `userType` | string | 用户类型，通常为 `"external"` |
| `isSidechain` | boolean | 是否为侧边栏对话 |
| `permissionMode` | string | 权限模式（首条消息）|
| `message` | object | 消息内容（见下表）|
| `toolUseResult` | any | 工具调用结果（部分消息）|
| `sourceToolAssistantUUID` | string | 工具来源的 assistant 消息 UUID |
| `slug` | string | 消息短标签（用于显示）|

**permissionMode 取值**：

| 值 | 说明 |
|---|-----|
| `default` | 默认模式，每次操作需要确认 |
| `acceptEdits` | 自动接受编辑操作 |
| `plan` | 规划模式 |
| `bypassPermissions` | 跳过所有权限检查 |

**message 字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `role` | string | 固定为 `"user"` |
| `content` | array | 内容数组 |

---

### 4. assistant（AI 响应消息）

AI 的响应消息，可能包含思考、文本和工具调用。

```json
{
  "parentUuid": "3e118c31-1391-484a-8ca8-50a386712358",
  "isSidechain": false,
  "userType": "external",
  "cwd": "e:\\workspaces_2026_python\\claude-code-runner",
  "sessionId": "c102b7ad-6e4b-4c03-b5da-21cfba48f81f",
  "version": "2.1.45",
  "gitBranch": "master",
  "message": {
    "id": "msg_20260218100041f5b6a7099bb94b8f",
    "type": "message",
    "role": "assistant",
    "model": "claude-sonnet-4-20250514",
    "content": [
      {
        "type": "thinking",
        "thinking": "让我分析一下这个问题...",
        "signature": ""
      },
      {
        "type": "text",
        "text": "我来帮你分析这个项目..."
      },
      {
        "type": "tool_use",
        "id": "call_33f4a566fb7e425a9f6327b4",
        "name": "Read",
        "input": {
          "file_path": "e:\\workspaces\\project\\main.py"
        }
      }
    ],
    "stop_reason": "tool_use",
    "stop_sequence": null,
    "usage": {
      "input_tokens": 1500,
      "output_tokens": 300
    }
  },
  "type": "assistant",
  "uuid": "9c71480b-443c-49ef-8722-079508367295",
  "timestamp": "2026-02-18T02:01:02.619Z"
}
```

**顶层字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"assistant"` |
| `uuid` | string | 消息唯一标识 (UUID) |
| `parentUuid` | string | 父消息 UUID |
| `sessionId` | string | 会话唯一标识 |
| `timestamp` | string | ISO 8601 时间戳 |
| `cwd` | string | 当前工作目录 |
| `version` | string | Claude Code 版本号 |
| `gitBranch` | string | 当前 Git 分支名 |
| `userType` | string | 用户类型 |
| `isSidechain` | boolean | 是否为侧边栏对话 |
| `slug` | string | 消息短标签（可选）|
| `message` | object | 消息内容（见下表）|

**message 字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `id` | string | API 消息 ID |
| `type` | string | 固定为 `"message"` |
| `role` | string | 固定为 `"assistant"` |
| `model` | string | 使用的模型名称 |
| `content` | array | 内容数组 |
| `stop_reason` | string \| null | 停止原因 |
| `stop_sequence` | string \| null | 停止序列 |
| `usage` | object | Token 使用统计 |

**stop_reason 取值**：

| 值 | 说明 |
|---|-----|
| `end_turn` | 正常结束 |
| `tool_use` | 调用工具 |
| `max_tokens` | 达到最大 token 限制 |
| `stop_sequence` | 遇到停止序列 |

**usage 字段说明**：

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `input_tokens` | number | 输入 token 数 |
| `output_tokens` | number | 输出 token 数 |

---

## Content 类型

`message.content` 数组中的每一项可以是以下类型：

### 1. text（文本内容）

```json
{
  "type": "text",
  "text": "这是文本内容..."
}
```

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"text"` |
| `text` | string | 文本内容 |

### 2. thinking（思考过程）

模型的内部思考过程（Extended Thinking）。

```json
{
  "type": "thinking",
  "thinking": "让我分析一下这个问题...\n首先需要...",
  "signature": ""
}
```

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"thinking"` |
| `thinking` | string | 思考内容 |
| `signature` | string | 签名（通常为空）|

### 3. tool_use（工具调用）

AI 请求调用工具。

```json
{
  "type": "tool_use",
  "id": "call_33f4a566fb7e425a9f6327b4",
  "name": "Read",
  "input": {
    "file_path": "e:\\workspaces\\project\\main.py"
  }
}
```

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"tool_use"` |
| `id` | string | 工具调用唯一标识 |
| `name` | string | 工具名称 |
| `input` | object | 工具输入参数 |

**常用工具名称**：

| 工具名 | 说明 |
|-------|-----|
| `Read` | 读取文件 |
| `Write` | 写入文件 |
| `Edit` | 编辑文件 |
| `Bash` | 执行命令 |
| `Glob` | 文件模式匹配 |
| `Grep` | 内容搜索 |
| `Task` | 启动子代理 |

### 4. tool_result（工具结果）

工具执行的返回结果（出现在 user 消息的 content 中）。

```json
{
  "type": "tool_result",
  "tool_use_id": "call_33f4a566fb7e425a9f6327b4",
  "content": "文件内容...",
  "is_error": false
}
```

| 字段 | 类型 | 说明 |
|-----|------|-----|
| `type` | string | 固定为 `"tool_result"` |
| `tool_use_id` | string | 对应的 tool_use ID |
| `content` | string | 工具返回内容 |
| `is_error` | boolean | 是否为错误结果（可选）|

---

## 消息链关系

消息通过 `uuid` 和 `parentUuid` 构成链式结构：

```
user (uuid=A, parentUuid=null)
  └── assistant (uuid=B, parentUuid=A)
        └── user (uuid=C, parentUuid=B)  // 工具结果
              └── assistant (uuid=D, parentUuid=C)
                    └── ...
```

---

## 子代理会话

当使用 Task 工具启动子代理时，会在 `subagents/` 目录下创建独立的会话文件：

```
projects/{project}/
├── {main-session}.jsonl
└── subagents/
    └── agent-{id}.jsonl      # 子代理会话
```

子代理会话文件格式与主会话相同。

---

## 解析示例

### Python 解析代码

```python
import json
from pathlib import Path
from dataclasses import dataclass
from typing import Any

@dataclass
class Message:
    type: str
    uuid: str
    timestamp: str
    content: str
    tool_name: str | None = None
    is_error: bool = False

def parse_session(filepath: Path) -> list[Message]:
    """解析会话文件"""
    messages = []

    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            data = json.loads(line)
            msg_type = data.get('type')

            if msg_type == 'user':
                content = extract_text(data.get('message', {}))
                messages.append(Message(
                    type='user',
                    uuid=data.get('uuid', ''),
                    timestamp=data.get('timestamp', ''),
                    content=content,
                ))

            elif msg_type == 'assistant':
                content = extract_text(data.get('message', {}))
                tool_name = extract_tool_name(data.get('message', {}))
                messages.append(Message(
                    type='assistant',
                    uuid=data.get('uuid', ''),
                    timestamp=data.get('timestamp', ''),
                    content=content,
                    tool_name=tool_name,
                ))

    return messages

def extract_text(message: dict) -> str:
    """提取消息中的文本内容"""
    content = message.get('content', [])
    if isinstance(content, list):
        texts = []
        for item in content:
            if isinstance(item, dict):
                if item.get('type') == 'text':
                    texts.append(item.get('text', ''))
                elif item.get('type') == 'thinking':
                    texts.append(f"[思考] {item.get('thinking', '')}")
        return '\n'.join(texts)
    return ''

def extract_tool_name(message: dict) -> str | None:
    """提取工具名称"""
    content = message.get('content', [])
    if isinstance(content, list):
        for item in content:
            if isinstance(item, dict) and item.get('type') == 'tool_use':
                return item.get('name')
    return None
```

---

## 多轮对话结构分析

### 对话轮次定义

Claude Code 的多轮对话通过 `permissionMode` 属性区分不同的对话轮次：

```
用户消息 (permissionMode="default")  ← 新会话开始
    └── Assistant (thinking + text + tool_use)
          └── User (tool_result - 工具结果，无 permissionMode)
                └── Assistant (thinking + text + tool_use)
                      └── ...

用户消息 (permissionMode="default")  ← 新会话开始
    └── Assistant (response)
```

**判断规则**：
1. 用户消息带有 `permissionMode` 属性 → 新的对话轮次
2. 用户消息不带有 `permissionMode`，但内容包含 `tool_result` → 继续当前轮次
3. 用户消息不带有 `permissionMode`，且不包含 `tool_result` → 新的对话轮次

### 工具调用与结果

工具调用是一个完整的多步骤流程：

1. **Assistant 发送 tool_use**：AI 请求调用工具
2. **User 响应 tool_result**：工具执行结果返回给 AI

```json
// Assistant 消息 - 工具调用
{
  "type": "assistant",
  "uuid": "assistant-uuid-1",
  "parentUuid": "user-uuid-1",
  "message": {
    "content": [
      {
        "type": "tool_use",
        "id": "call_xxx",
        "name": "Read",
        "input": {"file_path": "..."}
      }
    ]
  }
}

// User 消息 - 工具结果
{
  "type": "user",
  "uuid": "user-uuid-2",
  "parentUuid": "assistant-uuid-1",
  "message": {
    "content": [
      {
        "type": "tool_result",
        "tool_use_id": "call_xxx",
        "content": "文件内容...",
        "is_error": false
      }
    ]
  }
}
```

### 消息过滤问题

**重要**：解析会话文件时需要注意消息过滤问题：

| 问题 | 原因 | 影响 |
|-----|------|-----|
| 空内容消息丢失 | `parse_content_blocks` 过滤空文本/thinking | 消息链断裂 |
| tool_use 后续消息丢失 | assistant 消息只有 tool_use 没有 text | 分组错误 |

**正确做法**：保留所有消息，即使内容为空：

```python
def parse_content_blocks(message_content: list) -> list[dict]:
    """解析消息内容为内容块列表"""
    blocks = []
    if not isinstance(message_content, list):
        return blocks

    for item in message_content:
        if not isinstance(item, dict):
            continue

        item_type = item.get("type")

        # 保留所有类型，即使内容为空
        if item_type == "text":
            blocks.append({
                "type": "text",
                "text": item.get("text", ""),  # 不再过滤空文本
            })
        elif item_type == "thinking":
            blocks.append({
                "type": "thinking",
                "thinking": item.get("thinking", ""),
            })
        elif item_type == "tool_use":
            blocks.append({
                "type": "tool_use",
                "tool_name": item.get("name", ""),
                "tool_input": item.get("input", {}),
                "tool_use_id": item.get("id", ""),
            })
        elif item_type == "tool_result":
            blocks.append({
                "type": "tool_result",
                "tool_use_id": item.get("tool_use_id", ""),
                "content": item.get("content", ""),
                "is_error": item.get("is_error", False),
            })

    return blocks
```

---

### 用户输入类型区分

用户消息（user 类型）可以通过 `message.content` 中的内容类型区分不同场景：

#### 输入类型分类

| 类型 | 识别特征 | 典型场景 |
|------|---------|---------|
| **ide_selection** | content 包含 `<ide_selection>` 标签 | 用户选中代码后提问 |
| **ide_opened_file** | content 包含 `<ide_opened_file>` 标签 | 用户打开文件后操作 |
| **tool_result** | content 包含 `tool_result` 类型 | 工具执行结果返回 |
| **普通文本** | content 只包含 `text` 类型 | 直接输入的任务描述 |

#### 输入类型示例

**1. ide_selection（代码选中）**
```json
{
  "type": "user",
  "uuid": "8bb0c20d-13b2-4f41-9807-2e43e5123f6e",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "<ide_selection>The user selected the lines 78 to 78 from ...</ide_selection>"
      },
      {
        "type": "text",
        "text": "帮我实现##v0.2.3的任务..."
      }
    ]
  },
  "permissionMode": "acceptEdits"
}
```

**2. ide_opened_file（文件打开）**
```json
{
  "type": "user",
  "uuid": "b98f3591-1aa3-4e8a-b8c9-8625163552f7",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "text",
        "text": "<ide_opened_file>The user opened the file ... in the IDE.</ide_opened_file>"
      },
      {
        "type": "text",
        "text": "继续"
      }
    ]
  }
}
```

**3. tool_result（工具结果）**
```json
{
  "type": "user",
  "uuid": "f22473bd-55e7-4ac6-9bd3-d2a88e716dda",
  "message": {
    "role": "user",
    "content": [
      {
        "type": "tool_result",
        "tool_use_id": "call_xxx",
        "content": "文件内容...",
        "is_error": false
      }
    ]
  },
  "sourceToolAssistantUUID": "7ab1374a-172d-49a1-9b7c-dec6eab2198a"
}
```

#### 轮次区分判断条件

多轮对话中，可以通过以下条件判断是否属于新的对话轮次：

| 判断条件 | 说明 | 示例 |
|---------|------|------|
| `permissionMode` 字段存在 | **新任务发起**（最可靠） | 会话的首条用户消息 |
| `parentUuid === null` | 首条用户消息 | 会话的第一轮输入 |
| `content 包含 tool_result` | 继续当前对话 | 工具执行结果返回 |
| `timestamp 间隔 > 阈值` | 会话中断后继续 | 用户长时间未操作后继续 |

**重要**：`permissionMode` 字段**仅出现在首条用户消息**中，是判断新任务发起最可靠的依据。

**简化后的轮次判断算法**：

```python
def determine_round_type(message: dict, prev_msg: dict | None = None) -> str:
    """
    判断当前用户消息属于哪一轮

    判断优先级：
    1. permissionMode 存在 → 新会话（最可靠）
    2. parentUuid 为 null → 新会话
    3. 内容包含 tool_result → 继续当前对话
    4. 时间间隔 > 阈值 → 会话恢复

    Returns:
        "new_session": 全新会话的首条消息
        "continue": 继续当前对话
        "new_round": 新的一轮对话
        "resume": 从历史会话恢复
    """
    # 1. permissionMode 存在 = 新会话（最可靠）
    if message.get("permissionMode") is not None:
        return "new_session"

    # 2. parentUuid 为 null = 新会话
    if message.get("parentUuid") is None:
        return "new_session"

    # 3. 检查内容类型 - tool_result = 继续
    content = message.get("message", {}).get("content", [])
    has_tool_result = any(
        isinstance(c, dict) and c.get("type") == "tool_result"
        for c in content
    )
    if has_tool_result:
        return "continue"

    # 4. 时间间隔判断（可选）
    if prev_msg:
        prev_time = prev_msg.get("timestamp", "")
        curr_time = message.get("timestamp", "")
        if is_time_gap_large(prev_time, curr_time, threshold_minutes=5):
            return "resume"

    return "new_round"
```

**判断条件优先级**：
1. **最优先**：`permissionMode` 字段存在 → 100% 新任务
2. **次优先**：`parentUuid` 为 null → 新会话
3. **辅助判断**：内容类型为 `tool_result` → 继续当前对话
4. **兜底判断**：时间间隔大 → 会话恢复

---

### 轮次特征对比

| 轮次 | parentUuid | 内容特征 | 典型指令 | 复杂度 |
|------|-----------|---------|---------|--------|
| 第一轮 | null | ide_selection + 完整任务描述 | "帮我实现xxx功能..." | 高 |
| 继续轮 | 非null | ide_opened_file + 简短指令 | "继续"、"下一步" | 低 |
| 恢复轮 | 非null | ide_opened_file + 具体操作 | "将xxx更新到文档" | 中 |
| 工具结果 | 非null | tool_result | 工具返回内容 | - |

**规律**：随着对话轮次增加，用户输入从"详细上下文 + 完整指令"逐渐简化为"上下文引用 + 简短指令"的模式。

---

## 注意事项

1. **编码问题**：文件使用 UTF-8 编码，但某些系统可能存在编码不一致的问题
2. **大文件**：会话文件可能很大（数 MB），解析时注意内存使用
3. **敏感信息**：会话中可能包含 API Key 等敏感信息，展示时需要过滤
4. **路径差异**：不同操作系统的路径格式不同，解析时需要兼容处理
5. **版本兼容**：不同版本的 Claude Code 可能存在格式差异
6. **消息过滤**：解析时不要过滤空内容消息，否则会导致消息链断裂

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|-----|------|---------|
| 1.0 | 2026-02-18 | 初始版本，基于 Claude Code v2.1.45 分析 |
| 1.1 | 2026-02-19 | 添加多轮对话结构分析和消息过滤问题说明 |
| 1.2 | 2026-02-19 | 添加用户输入类型区分和轮次判断条件 |
| 1.3 | 2026-02-19 | 简化轮次判断条件，以 permissionMode 为主要依据 |

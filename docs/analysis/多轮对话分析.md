# 多轮对话分组显示问题分析

本文档分析当前会话界面多轮对话和分组显示的问题。

## 问题描述

会话界面：当前会话 功能 输出区，多轮对话和分组显示，结构不对。

## 历史记录格式分析

### 消息类型结构

根据实际历史记录分析，Claude Code 会话包含以下消息类型：

| 类型 | 出现位置 | 说明 |
|-----|---------|------|
| `queue-operation` | 文件开头 | 队列操作（dequeue） |
| `file-history-snapshot` | 文件开头 | 文件历史快照 |
| `user` | 交替出现 | 用户消息，包含初始输入和工具结果 |
| `assistant` | 交替出现 | AI 响应消息 |

### 多轮对话结构

Claude Code 的多轮对话通过 `permissionMode` 属性区分不同的对话轮次：

```
用户消息 (permissionMode="default")  ← 新会话开始
    └── Assistant (thinking + text + tool_use)
          └── User (tool_result - 工具结果，无 permissionMode)
                └── Assistant (thinking + text + tool_use)
                      └── ...

用户消息 (permissionMode="default")  ← 新会话开始
    └── Assistant (response)
```

**判断规则**：
1. 用户消息带有 `permissionMode` 属性 → 新的对话轮次
2. 用户消息不带有 `permissionMode`，但内容包含 `tool_result` → 继续当前轮次
3. 用户消息不带有 `permissionMode`，且不包含 `tool_result` → 新的对话轮次

### 消息链关系

消息通过 `uuid` 和 `parentUuid` 构建链式结构：

```json
{
  "uuid": "user-uuid-1",
  "parentUuid": null,  // 首条用户消息
  "type": "user"
}
  │
  ▼
{
  "uuid": "assistant-uuid-1",
  "parentUuid": "user-uuid-1",
  "type": "assistant"
}
  │
  ▼
{
  "uuid": "user-uuid-2",
  "parentUuid": "assistant-uuid-1",
  "type": "user",  // 工具结果
  "message": {
    "content": [{"type": "tool_result", ...}]
  }
}
  │
  ▼
{
  "uuid": "assistant-uuid-2",
  "parentUuid": "user-uuid-2",
  "type": "assistant"
}
```

## 当前实现分析

### 前端分组逻辑 (_groupByRounds)

```javascript
_groupByRounds(messages) {
    const rounds = [];
    let currentRound = null;

    messages.forEach(msg => {
        if (msg.role === 'user') {
            // 新的对话轮次
            currentRound = { user: msg, assistant: [] };
            rounds.push(currentRound);
        } else if (currentRound && msg.role === 'assistant') {
            currentRound.assistant.push(msg);
        }
    });

    return rounds;
}
```

### 后端消息过滤逻辑

```python
# 只有当有内容块时才添加消息
if content_blocks:
    messages.append({...})
```

## 发现的问题

### 问题 1：消息过滤导致顺序错乱

**问题描述**：
- 后端 API 会过滤掉没有内容块的消息
- 如果 `content` 数组为空，该消息不会被添加到返回列表
- 这会导致消息链断裂，前端无法正确重建对话轮次

**示例**：
```
原始顺序: user -> assistant(tooling) -> user(tool_result) -> assistant
API 返回:  user -> user(tool_result)     -> assistant  （assistant 丢失）
结果:      用户消息后直接跟工具结果，缺少中间的 AI 响应
```

### 问题 2：空内容块导致消息丢失

**分析代码** (`parse_content_blocks`)：
```python
if item_type == "text":
    text = item.get("text", "")
    if text:  # 空文本被过滤
        blocks.append({...})

elif item_type == "thinking":
    thinking = item.get("thinking", "")
    if thinking:  # 空思考被过滤
        blocks.append({...})
```

当 AI 只发送了 thinking 但没有 text 时，整个 assistant 消息可能被过滤。

### 问题 3：多轮对话识别不完整

当前分组逻辑只基于 `role` 字段判断，但实际对话结构更复杂：
- 工具调用后的人类响应（tool_result）也是 `user` 角色
- 需要根据 `parentUuid` 来判断是否是新的对话轮次

### 问题 4：缺少新会话可靠判断依据

**关键发现**：`permissionMode` 字段仅出现在首条用户消息中，是判断新任务发起最可靠的依据。

| 判断条件 | 可靠性 | 说明 |
|---------|-------|------|
| `permissionMode` 存在 | **最高** | 仅出现在首条用户消息 |
| `parentUuid === null` | 高 | 首条消息 |
| `tool_result` 内容 | 中 | 继续当前对话 |
| 时间间隔 > 阈值 | 低 | 可能误判 |

**重要**：`permissionMode` 是判断新任务的黄金标准，应作为首要判断条件。

## 对比分析

### 与 docs/会话格式.md 对比

| 文档描述 | 实际实现 | 差异 |
|---------|---------|------|
| Content 类型包含 text, thinking, tool_use, tool_result | 部分实现 | 缺少内容块过滤逻辑的完整处理 |
| 消息链通过 uuid/parentUuid 构建 | 仅基于 role 分组 | 未完全利用消息链关系 |

### 与 docs/输出实现.md 对比

| 文档描述 | 实际实现 | 差异 |
|---------|---------|------|
| 完整解析所有内容块类型 | 部分解析 | thinking 块可能为空时被过滤 |
| 支持多轮对话分组 | 存在问题 | 消息顺序可能错乱 |

## 解决方案建议

### 方案 1：修复后端消息过滤

**修改 `parse_content_blocks`**：
- 即使内容为空也保留消息结构
- 添加 `has_content` 标志

```python
def parse_content_blocks(message_content: list) -> list[dict]:
    blocks = []
    if not isinstance(message_content, list):
        return blocks

    for item in message_content:
        if not isinstance(item, dict):
            continue

        item_type = item.get("type")

        if item_type == "text":
            # 保留空文本块
            blocks.append({
                "type": "text",
                "text": item.get("text", ""),
            })
        # ... 其他类型类似处理

    return blocks
```

### 方案 2：改进前端分组逻辑

**基于消息链分组**：
```javascript
_groupByRounds(messages) {
    const rounds = [];
    let currentRound = null;
    let lastUserUuid = null;

    messages.forEach(msg => {
        if (msg.role === 'user') {
            // 检查是否是新的对话轮次
            // 通过检查 parentUuid 是否是最后一轮的 assistant
            if (!lastUserUuid || msg.parentUuid === lastUserUuid) {
                // 同一轮的用户响应（工具结果）
                if (currentRound) {
                    currentRound.assistant.push(msg);
                }
            } else {
                // 新的对话轮次
                currentRound = { user: msg, assistant: [] };
                rounds.push(currentRound);
            }
            lastUserUuid = msg.uuid;
        } else if (msg.role === 'assistant' && currentRound) {
            currentRound.assistant.push(msg);
        }
    });

    return rounds;
}
```

### 方案 3：完整消息链重建

**后端添加消息链完整性检查**：
- 确保每条 user 消息都有对应的 assistant 响应
- 补全缺失的消息

### 方案 4：基于 permissionMode 的轮次判断（推荐）

**核心原则**：`permissionMode` 字段是判断新任务发起最可靠的依据，应作为首要判断条件。

**简化后的前端分组逻辑**：

```javascript
_groupByRounds(messages) {
    const rounds = [];
    let currentRound = null;

    messages.forEach(msg => {
        if (msg.role === 'user') {
            // 1. permissionMode 存在 = 新会话（最可靠）
            if (msg.permissionMode) {
                currentRound = { user: msg, assistant: [] };
                rounds.push(currentRound);
            }
            // 2. 检查是否为 tool_result（继续当前对话）
            else if (this._isToolResult(msg)) {
                if (currentRound) {
                    currentRound.assistant.push(msg);
                }
            }
            // 3. 其他情况作为新轮次
            else {
                currentRound = { user: msg, assistant: [] };
                rounds.push(currentRound);
            }
        } else if (currentRound && msg.role === 'assistant') {
            currentRound.assistant.push(msg);
        }
    });

    return rounds;
}

/**
 * 判断是否为工具结果消息
 */
_isToolResult(message) {
    const content = message.content || [];
    return content.some(block => block.type === 'tool_result');
}
```

**简化后的后端判断逻辑**：

```python
def determine_round_type(message: dict, prev_msg: dict = None) -> str:
    """基于 permissionMode 的轮次判断"""
    # 1. permissionMode 存在 = 新会话（最可靠）
    if message.get("permissionMode") is not None:
        return "new_session"

    # 2. parentUuid 为 null = 新会话
    if message.get("parentUuid") is None:
        return "new_session"

    # 3. tool_result = 继续
    content = message.get("message", {}).get("content", [])
    if any(c.get("type") == "tool_result" for c in content):
        return "continue"

    # 4. 时间间隔大 = 恢复
    if prev_msg and is_time_gap_large(prev_msg, message):
        return "resume"

    return "new_round"
```

## 版本记录

| 版本 | 日期 | 变更说明 |
|-----|------|---------|
| 1.0 | 2026-02-19 | 初始版本，分析多轮对话分组问题 |
| 1.1 | 2026-02-19 | 添加 permissionMode 作为新会话判断依据，推荐基于 permissionMode 的轮次判断方案 |

# 任务执行 - 测试文档

## 1. 测试策略

### 1.1 测试目标

验证任务执行 API 的功能完整性、性能和稳定性。

### 1.2 测试类型

| 测试类型 | 覆盖范围 | 测试工具 |
|---------|---------|---------|
| 单元测试 | 路由处理、数据模型、错误处理 | pytest |
| 集成测试 | API 端点、ClaudeCodeClient 集成 | FastAPI TestClient + pytest |
| E2E 测试 | 完整任务执行流程 | Playwright |

---

## 2. 单元测试

### 2.1 数据模型测试

#### TaskRequest 模型测试

```python
class TestTaskRequest:
    """TaskRequest 数据模型测试"""

    def test_valid_request(self):
        """测试有效请求"""
        task = TaskRequest(prompt="测试任务")
        assert task.prompt == "测试任务"
        assert task.working_dir is None
        assert task.tools is None
        assert task.continue_conversation is False

    def test_full_request(self):
        """测试完整参数请求"""
        task = TaskRequest(
            prompt="测试任务",
            working_dir="/test/path",
            tools=["Read", "Write"],
            continue_conversation=True,
            resume="session-123"
        )
        assert task.prompt == "测试任务"
        assert task.working_dir == "/test/path"
        assert task.tools == ["Read", "Write"]
        assert task.continue_conversation is True
        assert task.resume == "session-123"

    def test_empty_prompt_validation(self):
        """测试空 prompt 验证"""
        with pytest.raises(ValidationError):
            TaskRequest(prompt="")

    def test_prompt_max_length(self):
        """测试 prompt 最大长度限制"""
        long_prompt = "a" * 10001
        with pytest.raises(ValidationError):
            TaskRequest(prompt=long_prompt)
```

#### TaskResponse 模型测试

```python
class TestTaskResponse:
    """TaskResponse 数据模型测试"""

    def test_success_response(self):
        """测试成功响应"""
        response = TaskResponse(
            success=True,
            message="任务完成",
            session_id="abc123",
            cost_usd=0.025,
            duration_ms=3500,
            files_changed=["/test/file.py"],
            tools_used=["Read", "Edit"]
        )
        assert response.success is True
        assert response.session_id == "abc123"
        assert response.cost_usd == 0.025

    def test_failed_response(self):
        """测试失败响应"""
        response = TaskResponse(
            success=False,
            message="任务失败"
        )
        assert response.success is False
        assert response.session_id is None

    def test_default_values(self):
        """测试默认值"""
        response = TaskResponse(success=True, message="完成")
        assert response.files_changed == []
        assert response.tools_used == []
```

### 2.2 路由处理测试

```python
class TestTaskRouter:
    """任务路由测试"""

    @pytest.fixture
    def client(self):
        """创建测试客户端"""
        from fastapi.testclient import TestClient
        from app.main import app
        return TestClient(app)

    def test_run_task_endpoint_exists(self):
        """测试任务端点存在"""
        from app.routers.task import router
        assert any(route.path == "" for route in router.routes)

    def test_stream_endpoint_exists(self):
        """测试流式端点存在"""
        from app.routers.task import router
        assert any(route.path == "/stream" for route in router.routes)
```

---

## 3. 集成测试

### 3.1 同步任务执行测试

```python
class TestSyncTaskExecution:
    """同步任务执行集成测试"""

    @pytest.fixture
    def mock_client(self):
        """Mock ClaudeCodeClient"""
        with patch("app.routers.task.ClaudeCodeClient") as mock:
            mock_instance = MagicMock()
            mock_instance.run = AsyncMock(return_value=TaskResult(
                success=True,
                message="测试结果",
                session_id="test-session",
                cost_usd=0.01,
                duration_ms=1000,
                files_changed=[],
                tools_used=["Read"]
            ))
            mock.return_value = mock_instance
            yield mock_instance

    @pytest.mark.asyncio
    async def test_sync_task_success(self, mock_client):
        """测试同步任务成功执行"""
        response = client.post("/api/task", json={
            "prompt": "测试任务"
        })

        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert data["message"] == "测试结果"

    @pytest.mark.asyncio
    async def test_sync_task_with_working_dir(self, mock_client):
        """测试带工作目录的任务"""
        response = client.post("/api/task", json={
            "prompt": "测试任务",
            "working_dir": "/custom/path"
        })

        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_sync_task_with_tools(self, mock_client):
        """测试带工具列表的任务"""
        response = client.post("/api/task", json={
            "prompt": "测试任务",
            "tools": ["Read", "Write"]
        })

        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_sync_task_validation_error(self):
        """测试请求体验证错误"""
        response = client.post("/api/task", json={})

        assert response.status_code == 422  # Validation Error
```

### 3.2 流式任务执行测试

```python
class TestStreamTaskExecution:
    """流式任务执行集成测试"""

    @pytest.fixture
    def mock_stream_client(self):
        """Mock 流式客户端"""
        with patch("app.routers.task.ClaudeCodeClient") as mock:
            mock_instance = MagicMock()

            async def mock_stream():
                yield StreamMessage(
                    type=MessageType.TEXT,
                    content="开始执行"
                )
                yield StreamMessage(
                    type=MessageType.TOOL_USE,
                    content="调用工具",
                    tool_name="Read"
                )
                yield StreamMessage(
                    type=MessageType.COMPLETE,
                    content="完成",
                    metadata={"session_id": "test", "cost_usd": 0.01}
                )

            mock_instance.run_stream = mock_stream
            mock.return_value = mock_instance
            yield mock_instance

    def test_stream_endpoint_response_type(self):
        """测试流式端点响应类型"""
        response = client.post("/api/task/stream", json={
            "prompt": "测试任务"
        }, stream=True)

        assert response.status_code == 200
        assert response.headers["content-type"] == "text/event-stream; charset=utf-8"

    def test_stream_sse_format(self):
        """测试 SSE 格式"""
        # 验证响应格式为 data: {...}\n\n
        pass
```

### 3.3 会话管理测试

```python
class TestSessionContinuation:
    """会话延续测试"""

    def test_continue_conversation_param(self):
        """测试 continue_conversation 参数"""
        response = client.post("/api/task", json={
            "prompt": "继续之前的任务",
            "continue_conversation": True
        })

        assert response.status_code == 200

    def test_resume_session_param(self):
        """测试 resume 参数"""
        response = client.post("/api/task", json={
            "prompt": "恢复会话",
            "resume": "session-abc123"
        })

        assert response.status_code == 200

    def test_both_params_error(self):
        """测试同时使用 continue_conversation 和 resume 的错误"""
        response = client.post("/api/task", json={
            "prompt": "测试",
            "continue_conversation": True,
            "resume": "session-abc123"
        })

        # 应该返回错误或后者覆盖前者
        assert response.status_code in [200, 400]
```

---

## 4. E2E 测试

### 4.1 完整任务流程测试

```python
# tests/e2e/test_task_execution.py
from playwright.sync_api import Page, expect

class TestTaskExecutionE2E:
    """任务执行端到端测试"""

    def test_sync_task_execution_flow(self, page: Page):
        """测试同步任务执行完整流程"""
        # 1. 打开页面
        page.goto("http://127.0.0.1:8000/")

        # 2. 输入任务
        page.fill("textarea[name='prompt']", "列出当前目录文件")

        # 3. 点击执行
        page.click("button[type='submit']")

        # 4. 等待结果
        expect(page.locator(".result")).to_be_visible(timeout=10000)

        # 5. 验证结果
        result = page.locator(".result").text_content()
        assert "success" in result.lower() or "文件" in result

    def test_stream_task_execution_flow(self, page: Page):
        """测试流式任务执行完整流程"""
        page.goto("http://127.0.0.1:8000/")

        # 切换到流式模式（如果有开关）
        page.click("text=流式模式")

        # 输入任务
        page.fill("textarea[name='prompt']", "分析项目结构")

        # 点击执行
        page.click("button[type='submit']")

        # 验证实时输出显示
        expect(page.locator(".stream-output")).to_be_visible()

    def test_task_with_custom_tools(self, page: Page):
        """测试自定义工具列表"""
        page.goto("http://127.0.0.1:8000/")

        # 选择工具
        page.check("input[value='Read']")
        page.check("input[value='Write']")

        # 执行任务
        page.fill("textarea[name='prompt']", "测试")
        page.click("button[type='submit']")

        # 验证使用了指定的工具
        # ...
```

---

## 5. 性能测试

### 5.1 响应时间测试

```python
class TestTaskPerformance:
    """任务执行性能测试"""

    def test_sync_response_time(self):
        """测试同步响应时间 < 500ms (不含 Claude API 调用)"""
        start = time.time()
        response = client.post("/api/task", json={"prompt": "test"})
        duration = time.time() - start

        assert response.status_code == 200
        # 路由处理时间应 < 500ms
        assert duration < 0.5

    def test_concurrent_tasks(self):
        """测试并发任务处理"""
        import concurrent.futures

        def run_task():
            return client.post("/api/task", json={"prompt": "test"})

        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(run_task) for _ in range(5)]
            results = [f.result() for f in futures]

        # 所有请求都应成功或优雅失败
        assert len(results) == 5
```

---

## 6. 错误处理测试

### 6.1 异常场景测试

```python
class TestTaskErrorHandling:
    """任务错误处理测试"""

    def test_missing_prompt(self):
        """测试缺少 prompt"""
        response = client.post("/api/task", json={})
        assert response.status_code == 422

    def test_empty_prompt(self):
        """测试空 prompt"""
        response = client.post("/api/task", json={"prompt": ""})
        assert response.status_code == 422

    def test_invalid_working_dir(self):
        """测试无效工作目录"""
        # 模拟工作目录不存在的情况
        pass

    def test_api_error_handling(self):
        """测试 API 错误处理"""
        with patch("app.routers.task.ClaudeCodeClient") as mock:
            mock_instance = MagicMock()
            mock_instance.run = AsyncMock(side_effect=Exception("API Error"))
            mock.return_value = mock_instance

            response = client.post("/api/task", json={"prompt": "test"})

            assert response.status_code == 500
            data = response.json()
            assert data["success"] is False
```

---

## 7. 测试数据准备

### 7.1 Mock 数据

```python
# tests/fixtures/mock_responses.py

MOCK_TASK_SUCCESS = {
    "success": True,
    "message": "任务完成",
    "session_id": "test-session-123",
    "cost_usd": 0.025,
    "duration_ms": 3500,
    "files_changed": ["/test/file.py"],
    "tools_used": ["Read", "Edit"]
}

MOCK_STREAM_MESSAGES = [
    {"type": "text", "content": "开始执行任务"},
    {"type": "tool_use", "tool_name": "Glob", "tool_input": {"pattern": "*.py"}},
    {"type": "complete", "content": "完成", "metadata": {"cost_usd": 0.01}}
]
```

---

## 8. 运行测试

### 8.1 命令

```bash
# 运行所有测试
uv run pytest tests/ -v

# 运行单元测试
uv run pytest tests/ -v -m "not e2e"

# 运行集成测试
uv run pytest tests/ -v -k "integration"

# 运行 E2E 测试
uv run playwright test tests/e2e/

# 生成覆盖率报告
uv run pytest tests/ --cov=app --cov-report=html
```

---

## 9. 验收标准

- [ ] 单元测试覆盖率 ≥ 80%
- [ ] 所有 API 端点有对应测试用例
- [ ] 同步和流式模式都有测试覆盖
- [ ] 错误场景测试完整
- [ ] E2E 测试覆盖主要用户流程
- [ ] 性能测试验证响应时间要求

# å½“å‰ä¼šè¯è¾“å‡ºåŒºå®ç°æ–¹æ¡ˆ

æœ¬æ–‡æ¡£å®šä¹‰å½“å‰ä¼šè¯åŠŸèƒ½è¾“å‡ºåŒºçš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼ŒåŸºäº `docs/ä¼šè¯æ ¼å¼.md` ä¸­çš„ä¼šè¯æ ¼å¼åˆ†æã€‚

## 1. æ¦‚è¿°

### 1.1 ç›®æ ‡
- å®Œæ•´æ¸²æŸ“ Claude Code ä¼šè¯å†å²ä¸­çš„æ‰€æœ‰æ¶ˆæ¯ç±»å‹
- æ”¯æŒå¤šè½®å¯¹è¯çš„æ¸…æ™°å±•ç¤º
- æä¾›å·¥å…·è°ƒç”¨çš„å¯è§†åŒ–
- æ˜¾ç¤ºé”™è¯¯çŠ¶æ€å’Œæ€è€ƒè¿‡ç¨‹

### 1.2 æ¶ˆæ¯ç±»å‹æ˜ å°„

æ ¹æ® `docs/ä¼šè¯æ ¼å¼.md`ï¼Œéœ€è¦å¤„ç†ä»¥ä¸‹å†…å®¹ç±»å‹ï¼š

| åŸå§‹ç±»å‹ | å‰ç«¯æ˜¾ç¤º | è¯´æ˜ |
|---------|---------|------|
| `text` | æ–‡æœ¬æ¶ˆæ¯ | æ™®é€šæ–‡æœ¬å†…å®¹ |
| `thinking` | æ€è€ƒè¿‡ç¨‹ | å¯æŠ˜å æ˜¾ç¤º |
| `tool_use` | å·¥å…·è°ƒç”¨ | æ˜¾ç¤ºå·¥å…·åå’Œå‚æ•° |
| `tool_result` | å·¥å…·ç»“æœ | æ˜¾ç¤ºæ‰§è¡Œç»“æœæˆ–é”™è¯¯ |

## 2. æ•°æ®ç»“æ„è®¾è®¡

### 2.1 åç«¯ API å“åº”æ ¼å¼

```python
# æ¶ˆæ¯å†…å®¹å—
@dataclass
class ContentBlock:
    type: str  # text, thinking, tool_use, tool_result
    text: str | None = None
    thinking: str | None = None
    tool_name: str | None = None
    tool_input: dict | None = None
    tool_use_id: str | None = None
    is_error: bool = False

# æ¶ˆæ¯
@dataclass
class Message:
    role: str  # user, assistant
    content: list[ContentBlock]  # å†…å®¹å—åˆ—è¡¨
    timestamp: str | None = None
    uuid: str | None = None
    stop_reason: str | None = None
    usage: dict | None = None  # token ç»Ÿè®¡
```

### 2.2 å‰ç«¯ TypeScript æ¥å£

```typescript
// å†…å®¹å—ç±»å‹
type ContentBlockType = 'text' | 'thinking' | 'tool_use' | 'tool_result';

// å†…å®¹å—
interface ContentBlock {
    type: ContentBlockType;
    text?: string;
    thinking?: string;
    tool_name?: string;
    tool_input?: Record<string, any>;
    tool_use_id?: string;
    content?: string;  // tool_result çš„å†…å®¹
    is_error?: boolean;
}

// æ¶ˆæ¯
interface Message {
    role: 'user' | 'assistant';
    content: ContentBlock[];
    timestamp?: string;
    uuid?: string;
    stop_reason?: string;
    usage?: {
        input_tokens: number;
        output_tokens: number;
    };
}
```

## 3. åç«¯å®ç°

### 3.1 æ¶ˆæ¯è§£æå‡½æ•°

```python
def parse_content_blocks(message_content: list) -> list[dict]:
    """è§£ææ¶ˆæ¯å†…å®¹ä¸ºå†…å®¹å—åˆ—è¡¨"""
    blocks = []
    for item in message_content:
        if not isinstance(item, dict):
            continue

        item_type = item.get("type")

        if item_type == "text":
            blocks.append({
                "type": "text",
                "text": item.get("text", ""),
            })

        elif item_type == "thinking":
            blocks.append({
                "type": "thinking",
                "thinking": item.get("thinking", ""),
            })

        elif item_type == "tool_use":
            blocks.append({
                "type": "tool_use",
                "tool_name": item.get("name", ""),
                "tool_input": item.get("input", {}),
                "tool_use_id": item.get("id", ""),
            })

        elif item_type == "tool_result":
            blocks.append({
                "type": "tool_result",
                "tool_use_id": item.get("tool_use_id", ""),
                "content": item.get("content", ""),
                "is_error": item.get("is_error", False),
            })

    return blocks
```

### 3.2 API ç«¯ç‚¹æ›´æ–°

```python
@router.get("/sessions/{session_id}/messages")
async def get_session_messages(session_id: str):
    """è·å–ä¼šè¯çš„æ¶ˆæ¯å†å²"""
    session_file = find_session_file(session_id)

    if not session_file:
        raise HTTPException(status_code=404, detail="ä¼šè¯ä¸å­˜åœ¨")

    messages = []
    project_path = None

    try:
        with open(session_file, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    data = json.loads(line)
                    msg_type = data.get("type")

                    if msg_type == "user":
                        if project_path is None and data.get("cwd"):
                            project_path = data.get("cwd")

                        message = data.get("message", {})
                        content_blocks = parse_content_blocks(
                            message.get("content", [])
                        )

                        messages.append({
                            "role": "user",
                            "content": content_blocks,
                            "timestamp": data.get("timestamp"),
                            "uuid": data.get("uuid"),
                        })

                    elif msg_type == "assistant":
                        message = data.get("message", {})
                        content_blocks = parse_content_blocks(
                            message.get("content", [])
                        )

                        messages.append({
                            "role": "assistant",
                            "content": content_blocks,
                            "timestamp": data.get("timestamp"),
                            "uuid": data.get("uuid"),
                            "stop_reason": message.get("stop_reason"),
                            "usage": message.get("usage"),
                        })
                except json.JSONDecodeError:
                    continue
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"è¯»å–ä¼šè¯æ–‡ä»¶å¤±è´¥: {str(e)}")

    return {
        "session_id": session_id,
        "project_path": project_path or "",
        "messages": messages,
    }
```

## 4. å‰ç«¯å®ç°

### 4.1 æ¶ˆæ¯æ¸²æŸ“å™¨ç±»

```javascript
class MessageRenderer {
    constructor(outputEl) {
        this.outputEl = outputEl;
    }

    /**
     * æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
     * @param {Message[]} messages æ¶ˆæ¯åˆ—è¡¨
     */
    renderMessages(messages) {
        this.outputEl.innerHTML = '';

        if (messages.length === 0) {
            this.outputEl.innerHTML = '<div class="output-placeholder">æš‚æ— å†å²æ¶ˆæ¯</div>';
            return;
        }

        // æŒ‰è½®æ¬¡åˆ†ç»„
        const rounds = this.groupByRounds(messages);

        rounds.forEach((round, index) => {
            const roundEl = this.createRoundElement(round, index + 1);
            this.outputEl.appendChild(roundEl);
        });

        this.scrollToBottom();
    }

    /**
     * æŒ‰è½®æ¬¡åˆ†ç»„æ¶ˆæ¯
     */
    groupByRounds(messages) {
        const rounds = [];
        let currentRound = null;

        messages.forEach(msg => {
            if (msg.role === 'user') {
                // æ–°çš„å¯¹è¯è½®æ¬¡
                currentRound = { user: msg, assistant: [] };
                rounds.push(currentRound);
            } else if (currentRound) {
                currentRound.assistant.push(msg);
            }
        });

        return rounds;
    }

    /**
     * åˆ›å»ºå¯¹è¯è½®æ¬¡å…ƒç´ 
     */
    createRoundElement(round, roundNumber) {
        const roundEl = document.createElement('div');
        roundEl.className = 'conversation-round';
        roundEl.id = `round-${roundNumber}`;

        roundEl.innerHTML = `
            <div class="round-header">
                <span class="round-number">ç¬¬ ${roundNumber} è½®</span>
            </div>
            <div class="round-user">
                <div class="message-role user-role">ğŸ‘¤ ç”¨æˆ·</div>
                <div class="message-content user-content">
                    ${this.renderUserContent(round.user)}
                </div>
            </div>
            <div class="round-assistant">
                <div class="message-role assistant-role">ğŸ¤– Claude</div>
                <div class="assistant-messages">
                    ${this.renderAssistantMessages(round.assistant)}
                </div>
            </div>
        `;

        return roundEl;
    }

    /**
     * æ¸²æŸ“ç”¨æˆ·æ¶ˆæ¯å†…å®¹
     */
    renderUserContent(message) {
        if (!message.content || message.content.length === 0) {
            return '<span class="empty-content">(æ— å†…å®¹)</span>';
        }

        // ç”¨æˆ·æ¶ˆæ¯é€šå¸¸æ˜¯ text æˆ– tool_result
        return message.content.map(block => {
            if (block.type === 'text') {
                return this.escapeHtml(block.text || '');
            } else if (block.type === 'tool_result') {
                return this.renderToolResult(block);
            }
            return '';
        }).join('');
    }

    /**
     * æ¸²æŸ“ AI å“åº”æ¶ˆæ¯
     */
    renderAssistantMessages(messages) {
        if (!messages || messages.length === 0) {
            return '';
        }

        // åˆå¹¶æ‰€æœ‰æ¶ˆæ¯çš„å†…å®¹å—
        const allBlocks = messages.flatMap(msg => msg.content || []);

        return allBlocks.map(block => {
            const timestamp = messages[0]?.timestamp;

            switch (block.type) {
                case 'text':
                    return this.renderTextBlock(block, timestamp);
                case 'thinking':
                    return this.renderThinkingBlock(block, timestamp);
                case 'tool_use':
                    return this.renderToolUseBlock(block, timestamp);
                case 'tool_result':
                    return this.renderToolResult(block, timestamp);
                default:
                    return '';
            }
        }).join('');
    }

    /**
     * æ¸²æŸ“æ–‡æœ¬å—
     */
    renderTextBlock(block, timestamp) {
        const timeStr = timestamp ? new Date(timestamp).toLocaleTimeString() : '';
        return `
            <div class="assistant-msg assistant-msg-text">
                <span class="timestamp">${timeStr}</span>
                <div class="content">${this.escapeHtml(block.text || '')}</div>
            </div>
        `;
    }

    /**
     * æ¸²æŸ“æ€è€ƒå—ï¼ˆå¯æŠ˜å ï¼‰
     */
    renderThinkingBlock(block, timestamp) {
        const thinking = block.thinking || '';
        if (!thinking) return '';

        const timeStr = timestamp ? new Date(timestamp).toLocaleTimeString() : '';
        const preview = thinking.substring(0, 100) + (thinking.length > 100 ? '...' : '');

        return `
            <div class="assistant-msg assistant-msg-thinking">
                <div class="thinking-header" onclick="this.parentElement.classList.toggle('expanded')">
                    <span class="timestamp">${timeStr}</span>
                    <span class="thinking-icon">ğŸ’­</span>
                    <span class="thinking-title">æ€è€ƒè¿‡ç¨‹</span>
                    <span class="thinking-toggle">â–¶</span>
                </div>
                <div class="thinking-preview">${this.escapeHtml(preview)}</div>
                <div class="thinking-content">${this.escapeHtml(thinking)}</div>
            </div>
        `;
    }

    /**
     * æ¸²æŸ“å·¥å…·è°ƒç”¨å—
     */
    renderToolUseBlock(block, timestamp) {
        const timeStr = timestamp ? new Date(timestamp).toLocaleTimeString() : '';
        const toolName = block.tool_name || 'Unknown';
        const toolInput = block.tool_input || {};
        const inputJson = JSON.stringify(toolInput, null, 2);

        return `
            <div class="assistant-msg assistant-msg-tool_use">
                <span class="timestamp">${timeStr}</span>
                <div class="tool-header">
                    <span class="tool-icon">ğŸ”§</span>
                    <span class="tool-name">${this.escapeHtml(toolName)}</span>
                </div>
                <div class="tool-input">
                    <pre>${this.escapeHtml(inputJson)}</pre>
                </div>
            </div>
        `;
    }

    /**
     * æ¸²æŸ“å·¥å…·ç»“æœå—
     */
    renderToolResult(block, timestamp) {
        const isError = block.is_error;
        const content = block.content || '';
        const msgClass = isError ? 'assistant-msg-error' : 'assistant-msg-tool_result';

        // æˆªæ–­è¿‡é•¿çš„ç»“æœ
        const displayContent = content.length > 500
            ? content.substring(0, 500) + '...\n[å†…å®¹å·²æˆªæ–­]'
            : content;

        return `
            <div class="assistant-msg ${msgClass}">
                <span class="result-label">${isError ? 'âŒ é”™è¯¯' : 'âœ… ç»“æœ'}</span>
                <div class="result-content">
                    <pre>${this.escapeHtml(displayContent)}</pre>
                </div>
            </div>
        `;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    scrollToBottom() {
        this.outputEl.scrollTop = this.outputEl.scrollHeight;
    }
}
```

### 4.2 CSS æ ·å¼

```css
/* æ€è€ƒå—æ ·å¼ */
.assistant-msg-thinking {
    background: rgba(251, 191, 36, 0.1);
    border-left-color: #fbbf24;
}

.thinking-header {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    padding: 4px 0;
}

.thinking-icon {
    font-size: 0.9rem;
}

.thinking-title {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.thinking-toggle {
    font-size: 0.7rem;
    transition: transform 0.2s;
}

.assistant-msg-thinking.expanded .thinking-toggle {
    transform: rotate(90deg);
}

.thinking-preview {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-top: 8px;
    font-style: italic;
}

.thinking-content {
    display: none;
    margin-top: 8px;
    font-size: 0.85rem;
    white-space: pre-wrap;
    color: var(--text-color);
}

.assistant-msg-thinking.expanded .thinking-content {
    display: block;
}

.assistant-msg-thinking.expanded .thinking-preview {
    display: none;
}

/* å·¥å…·è°ƒç”¨æ ·å¼ */
.assistant-msg-tool_use {
    background: rgba(16, 185, 129, 0.1);
    border-left-color: #10b981;
}

.tool-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.tool-icon {
    font-size: 1rem;
}

.tool-name {
    font-weight: 500;
    color: #10b981;
}

.tool-input pre {
    margin: 0;
    padding: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    font-size: 0.8rem;
    overflow-x: auto;
}

/* å·¥å…·ç»“æœæ ·å¼ */
.assistant-msg-tool_result {
    background: rgba(59, 130, 246, 0.1);
    border-left-color: #3b82f6;
}

.assistant-msg-error {
    background: rgba(239, 68, 68, 0.1);
    border-left-color: #ef4444;
}

.result-label {
    font-size: 0.8rem;
    font-weight: 500;
    margin-right: 8px;
}

.result-content pre {
    margin: 8px 0 0 0;
    padding: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    font-size: 0.8rem;
    overflow-x: auto;
    max-height: 200px;
    overflow-y: auto;
}

/* ç©ºå†…å®¹æ ·å¼ */
.empty-content {
    color: var(--text-muted);
    font-style: italic;
}
```

## 5. åœºæ™¯è¦†ç›–æ£€æŸ¥

### 5.1 å†å²æ¶ˆæ¯åœºæ™¯è¦†ç›–

| åœºæ™¯ | è¦†ç›–çŠ¶æ€ | è¯´æ˜ |
|-----|---------|------|
| ç”¨æˆ·æ–‡æœ¬æ¶ˆæ¯ | âœ… | æ”¯æŒ text ç±»å‹ |
| ç”¨æˆ·å·¥å…·ç»“æœ | âœ… | æ”¯æŒ tool_result ç±»å‹ |
| AI æ–‡æœ¬å“åº” | âœ… | æ”¯æŒ text ç±»å‹ |
| AI æ€è€ƒè¿‡ç¨‹ | âœ… | æ”¯æŒ thinking ç±»å‹ï¼ˆå¯æŠ˜å ï¼‰ |
| AI å·¥å…·è°ƒç”¨ | âœ… | æ”¯æŒ tool_use ç±»å‹ |
| å·¥å…·è°ƒç”¨é”™è¯¯ | âœ… | is_error æ ‡å¿—åŒºåˆ† |
| å¤šè½®å¯¹è¯ | âœ… | æŒ‰è½®æ¬¡åˆ†ç»„ |
| è¿ç»­ AI æ¶ˆæ¯ | âœ… | åˆå¹¶å†…å®¹å— |
| ç©ºæ¶ˆæ¯å†…å®¹ | âœ… | æ˜¾ç¤ºå ä½æ–‡æœ¬ |
| é•¿å†…å®¹æˆªæ–­ | âœ… | è¶…è¿‡ 500 å­—ç¬¦æˆªæ–­ |

### 5.2 å®æ—¶æ¶ˆæ¯åœºæ™¯è¦†ç›–

| åœºæ™¯ | è¦†ç›–çŠ¶æ€ | è¯´æ˜ |
|-----|---------|------|
| å®æ—¶æ–‡æœ¬æµ | âœ… | æ”¯æŒ SSE æµå¼ text |
| å®æ—¶å·¥å…·è°ƒç”¨ | âœ… | æ”¯æŒ tool_use äº‹ä»¶ |
| å®æ—¶é”™è¯¯ | âœ… | æ”¯æŒ error äº‹ä»¶ |
| å®Œæˆæ¶ˆæ¯ | âœ… | æ”¯æŒ complete äº‹ä»¶ |

## 6. å®ç°æ­¥éª¤

### 6.1 åç«¯ä¿®æ”¹
1. æ›´æ–° `app/routers/session.py` ä¸­çš„ `get_session_messages()` å‡½æ•°
2. æ·»åŠ  `parse_content_blocks()` è¾…åŠ©å‡½æ•°
3. æ‰©å±•æ¶ˆæ¯è¿”å›ç»“æ„

### 6.2 å‰ç«¯ä¿®æ”¹
1. æ›´æ–° `web/static/app.js` ä¸­çš„ `displayHistoryMessages()` æ–¹æ³•
2. æ·»åŠ å†…å®¹å—æ¸²æŸ“æ–¹æ³•
3. æ›´æ–° `web/static/style.css` æ·»åŠ æ–°æ ·å¼

### 6.3 æµ‹è¯•éªŒè¯
1. æµ‹è¯•å†å²æ¶ˆæ¯åŠ è½½
2. æµ‹è¯•å„ç±»å‹å†…å®¹å—æ¸²æŸ“
3. æµ‹è¯•å¤šè½®å¯¹è¯æ˜¾ç¤º
4. æµ‹è¯•é”™è¯¯çŠ¶æ€æ˜¾ç¤º

## 7. ç‰ˆæœ¬è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´è¯´æ˜ |
|-----|------|---------|
| 1.0 | 2026-02-18 | åˆå§‹æ–¹æ¡ˆè®¾è®¡ |
| 1.1 | 2026-02-19 | æ·»åŠ å¤šè½®å¯¹è¯åˆ†ç»„é—®é¢˜ä¿®å¤æ–¹æ¡ˆ |
| 1.2 | 2026-02-19 | æ·»åŠ ç”¨æˆ·è¾“å…¥ç±»å‹åŒºåˆ†å’Œè½®æ¬¡åˆ¤æ–­å®ç° |
| 1.3 | 2026-02-19 | ç®€åŒ–è½®æ¬¡åˆ¤æ–­æ¡ä»¶ï¼Œä»¥ permissionMode ä¸ºä¸»è¦ä¾æ® |

---

## 8. å¤šè½®å¯¹è¯åˆ†ç»„é—®é¢˜ä¿®å¤

### 8.1 é—®é¢˜æè¿°

å½“å‰å®ç°å­˜åœ¨å¤šè½®å¯¹è¯åˆ†ç»„ä¸æ­£ç¡®çš„é—®é¢˜ï¼š

1. **æ¶ˆæ¯è¿‡æ»¤å¯¼è‡´é¡ºåºé”™ä¹±**ï¼šåç«¯ API è¿‡æ»¤ç©ºå†…å®¹æ¶ˆæ¯ï¼Œå¯¼è‡´æ¶ˆæ¯é“¾æ–­è£‚
2. **åˆ†ç»„é€»è¾‘ä¸å®Œæ•´**ï¼šä»…åŸºäº `role` å­—æ®µåˆ¤æ–­ï¼Œæœªè€ƒè™‘å·¥å…·è°ƒç”¨åœºæ™¯
3. **æ¶ˆæ¯é“¾æ–­è£‚**ï¼šassistant æ¶ˆæ¯åªæœ‰ tool_use æ—¶å¯èƒ½è¢«è¿‡æ»¤

### 8.2 é—®é¢˜åˆ†æ

**åŸå§‹æ¶ˆæ¯é¡ºåº**ï¼š
```
user (prompt) -> assistant (thinking + tool_use) -> user (tool_result) -> assistant
```

**å½“å‰ API è¿”å›**ï¼ˆç”±äºè¿‡æ»¤ï¼‰ï¼š
```
user (prompt) -> user (tool_result) -> assistant
```

**ç»“æœ**ï¼šç”¨æˆ·æ¶ˆæ¯åç›´æ¥è·Ÿå·¥å…·ç»“æœï¼Œç¼ºå°‘ä¸­é—´çš„ AI å“åº”

### 8.3 ä¿®å¤æ–¹æ¡ˆ

#### æ–¹æ¡ˆ 1ï¼šä¿®å¤åç«¯æ¶ˆæ¯è¿‡æ»¤

ä¿®æ”¹ `parse_content_blocks` å‡½æ•°ï¼Œä¿ç•™æ‰€æœ‰å†…å®¹å—ï¼š

```python
def parse_content_blocks(message_content: list) -> list[dict]:
    """
    è§£ææ¶ˆæ¯å†…å®¹ä¸ºå†…å®¹å—åˆ—è¡¨

    é‡è¦ï¼šä¿ç•™æ‰€æœ‰å†…å®¹å—ï¼Œå³ä½¿ä¸ºç©º
    """
    blocks = []
    if not isinstance(message_content, list):
        return blocks

    for item in message_content:
        if not isinstance(item, dict):
            continue

        item_type = item.get("type")

        # ä¿ç•™æ‰€æœ‰ç±»å‹
        if item_type == "text":
            blocks.append({
                "type": "text",
                "text": item.get("text", ""),
            })

        elif item_type == "thinking":
            blocks.append({
                "type": "thinking",
                "thinking": item.get("thinking", ""),
            })

        elif item_type == "tool_use":
            blocks.append({
                "type": "tool_use",
                "tool_name": item.get("name", ""),
                "tool_input": item.get("input", {}),
                "tool_use_id": item.get("id", ""),
            })

        elif item_type == "tool_result":
            blocks.append({
                "type": "tool_result",
                "tool_use_id": item.get("tool_use_id", ""),
                "content": item.get("content", ""),
                "is_error": item.get("is_error", False),
            })

    return blocks
```

#### æ–¹æ¡ˆ 2ï¼šæ”¹è¿›å‰ç«¯åˆ†ç»„é€»è¾‘

ä¿®æ”¹ `_groupByRounds` æ–¹æ³•ï¼ŒåŸºäºæ¶ˆæ¯é“¾å…³ç³»åˆ†ç»„ï¼š

```javascript
/**
 * æŒ‰è½®æ¬¡åˆ†ç»„æ¶ˆæ¯ï¼ˆæ”¹è¿›ç‰ˆï¼‰
 * åŸºäºæ¶ˆæ¯é“¾å…³ç³»è¿›è¡Œåˆ†ç»„
 */
_groupByRounds(messages) {
    const rounds = [];
    let currentRound = null;
    let lastUserUuid = null;

    messages.forEach(msg => {
        if (msg.role === 'user') {
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„å¯¹è¯è½®æ¬¡
            // é€šè¿‡æ£€æŸ¥ parentUuid æ˜¯å¦æ˜¯æœ€åä¸€è½®çš„ assistant
            if (!lastUserUuid || msg.parentUuid === lastUserUuid) {
                // åŒä¸€è½®çš„ç”¨æˆ·å“åº”ï¼ˆå·¥å…·ç»“æœï¼‰
                if (currentRound) {
                    currentRound.assistant.push(msg);
                }
            } else {
                // æ–°çš„å¯¹è¯è½®æ¬¡
                currentRound = { user: msg, assistant: [] };
                rounds.push(currentRound);
            }
            lastUserUuid = msg.uuid;
        } else if (msg.role === 'assistant' && currentRound) {
            currentRound.assistant.push(msg);
        }
    });

    return rounds;
}
```

#### æ–¹æ¡ˆ 3ï¼šåç«¯æ·»åŠ æ¶ˆæ¯é“¾å®Œæ•´æ€§æ£€æŸ¥

åœ¨ API å±‚é¢ç¡®ä¿æ¶ˆæ¯é“¾å®Œæ•´ï¼š

```python
def build_message_chain(session_file: Path) -> list[dict]:
    """æ„å»ºå®Œæ•´çš„æ¶ˆæ¯é“¾"""
    raw_messages = []

    with open(session_file, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                data = json.loads(line)
                msg_type = data.get("type")
                if msg_type in ("user", "assistant"):
                    raw_messages.append(data)
            except json.JSONDecodeError:
                continue

    # æŒ‰ timestamp æ’åº
    raw_messages.sort(key=lambda x: x.get("timestamp", ""))

    # æ„å»ºæ¶ˆæ¯é“¾
    messages = []
    for data in raw_messages:
        msg_type = data.get("type")

        if msg_type == "user":
            message = data.get("message", {})
            content_blocks = parse_content_blocks(message.get("content", []))

            messages.append({
                "role": "user",
                "content": content_blocks,
                "timestamp": data.get("timestamp"),
                "uuid": data.get("uuid"),
                "parentUuid": data.get("parentUuid"),
            })

        elif msg_type == "assistant":
            message = data.get("message", {})
            content_blocks = parse_content_blocks(message.get("content", []))

            # å³ä½¿æ²¡æœ‰å†…å®¹å—ï¼Œä¹Ÿä¿ç•™æ¶ˆæ¯
            if content_blocks or message.get("content"):
                messages.append({
                    "role": "assistant",
                    "content": content_blocks,
                    "timestamp": data.get("timestamp"),
                    "uuid": data.get("uuid"),
                    "parentUuid": data.get("parentUuid"),
                    "stop_reason": message.get("stop_reason"),
                    "usage": message.get("usage"),
                })

    return messages
```

### 8.4 æµ‹è¯•ç”¨ä¾‹

```python
class TestMultiRoundGrouping:
    """å¤šè½®å¯¹è¯åˆ†ç»„æµ‹è¯•"""

    def test_simple_round(self):
        """æµ‹è¯•å•è½®å¯¹è¯"""
        messages = [
            {"role": "user", "uuid": "u1", "content": [{"type": "text", "text": "hello"}]},
            {"role": "assistant", "uuid": "a1", "parentUuid": "u1", "content": [{"type": "text", "text": "hi"}]},
        ]
        rounds = group_by_rounds(messages)
        assert len(rounds) == 1
        assert rounds[0]["user"]["uuid"] == "u1"
        assert len(rounds[0]["assistant"]) == 1

    def test_tool_call_round(self):
        """æµ‹è¯•å·¥å…·è°ƒç”¨å¯¹è¯"""
        messages = [
            {"role": "user", "uuid": "u1", "content": [{"type": "text", "text": "read file"}]},
            {"role": "assistant", "uuid": "a1", "parentUuid": "u1", "content": [
                {"type": "tool_use", "tool_name": "Read", "tool_input": {"file_path": "a.txt"}}
            ]},
            {"role": "user", "uuid": "u2", "parentUuid": "a1", "content": [
                {"type": "tool_result", "content": "file content"}
            ]},
            {"role": "assistant", "uuid": "a2", "parentUuid": "u2", "content": [
                {"type": "text", "text": "Here is the content"}
            ]},
        ]
        rounds = group_by_rounds(messages)
        assert len(rounds) == 1
        assert len(rounds[0]["assistant"]) == 2  # tool_use + response

    def test_multi_rounds(self):
        """æµ‹è¯•å¤šè½®å¯¹è¯"""
        messages = [
            # æ–°ä¼šè¯ 1 (å¸¦æœ‰ permissionMode)
            {"role": "user", "uuid": "u1", "permissionMode": "default", "content": [{"type": "text", "text": "task 1"}]},
            {"role": "assistant", "uuid": "a1", "parentUuid": "u1", "content": [{"type": "text", "text": "done"}]},
            # æ–°ä¼šè¯ 2 (å¸¦æœ‰ permissionMode)
            {"role": "user", "uuid": "u2", "permissionMode": "default", "content": [{"type": "text", "text": "task 2"}]},
            {"role": "assistant", "uuid": "a2", "parentUuid": "u2", "content": [{"type": "text", "text": "done"}]},
        ]
        rounds = group_by_rounds(messages)
        assert len(rounds) == 2

---

## 9. ç”¨æˆ·è¾“å…¥ç±»å‹åŒºåˆ†å®ç°

### 9.1 éœ€æ±‚èƒŒæ™¯

æ ¹æ® `docs/ä¼šè¯æ ¼å¼.md` ä¸­çš„åˆ†æï¼Œç”¨æˆ·æ¶ˆæ¯å¯ä»¥é€šè¿‡å†…å®¹ç±»å‹åŒºåˆ†ä¸åŒåœºæ™¯ï¼Œè¿›è€Œå®ç°æ›´å‡†ç¡®çš„è½®æ¬¡åˆ¤æ–­å’Œ UI å±•ç¤ºã€‚

### 9.2 è¾“å…¥ç±»å‹è¯†åˆ«

#### åç«¯å®ç°

```python
from enum import Enum
from dataclasses import dataclass
from typing import Literal

class UserInputType(Enum):
    """ç”¨æˆ·è¾“å…¥ç±»å‹æšä¸¾"""
    IDE_SELECTION = "ide_selection"      # ç”¨æˆ·é€‰ä¸­ä»£ç 
    IDE_OPENED_FILE = "ide_opened_file"  # ç”¨æˆ·æ‰“å¼€æ–‡ä»¶
    TOOL_RESULT = "tool_result"          # å·¥å…·æ‰§è¡Œç»“æœ
    PLAIN_TEXT = "plain_text"             # æ™®é€šæ–‡æœ¬è¾“å…¥

@dataclass
class UserInputContext:
    """ç”¨æˆ·è¾“å…¥ä¸Šä¸‹æ–‡"""
    input_type: UserInputType
    has_context: bool  # æ˜¯å¦æœ‰ IDE ä¸Šä¸‹æ–‡
    context_content: str | None = None
    raw_text: str | None = None

def detect_user_input_type(message: dict) -> UserInputContext:
    """
    æ£€æµ‹ç”¨æˆ·è¾“å…¥ç±»å‹

    æ ¹æ® message.content ä¸­çš„å†…å®¹ç±»å‹åˆ¤æ–­ç”¨æˆ·è¾“å…¥åœºæ™¯
    """
    content = message.get("message", {}).get("content", [])

    if not isinstance(content, list):
        return UserInputContext(
            input_type=UserInputType.PLAIN_TEXT,
            has_context=False,
        )

    has_ide_selection = False
    has_ide_opened_file = False
    has_tool_result = False
    raw_text_parts = []

    for block in content:
        if not isinstance(block, dict):
            continue

        block_type = block.get("type")
        block_text = block.get("text", "")

        if block_type == "text":
            if "<ide_selection>" in block_text:
                has_ide_selection = True
                raw_text_parts.append(block_text)
            elif "<ide_opened_file>" in block_text:
                has_ide_opened_file = True
                raw_text_parts.append(block_text)
            else:
                raw_text_parts.append(block_text)

        elif block_type == "tool_result":
            has_tool_result = True

    # åˆ¤æ–­è¾“å…¥ç±»å‹ä¼˜å…ˆçº§
    if has_ide_selection:
        return UserInputContext(
            input_type=UserInputType.IDE_SELECTION,
            has_context=True,
            context_content=raw_text_parts[0] if raw_text_parts else None,
            raw_text="".join(raw_text_parts),
        )
    elif has_ide_opened_file:
        return UserInputContext(
            input_type=UserInputType.IDE_OPENED_FILE,
            has_context=True,
            context_content=raw_text_parts[0] if raw_text_parts else None,
            raw_text="".join(raw_text_parts),
        )
    elif has_tool_result:
        return UserInputContext(
            input_type=UserInputType.TOOL_RESULT,
            has_context=False,
            raw_text="[å·¥å…·ç»“æœ]",
        )
    else:
        return UserInputContext(
            input_type=UserInputType.PLAIN_TEXT,
            has_context=False,
            raw_text="".join(raw_text_parts) if raw_text_parts else "",
        )
```

#### API è¿”å›ç»“æ„æ‰©å±•

```python
@router.get("/sessions/{session_id}/messages")
async def get_session_messages(session_id: str):
    """è·å–ä¼šè¯çš„æ¶ˆæ¯å†å²ï¼ˆåŒ…å«è¾“å…¥ç±»å‹ä¿¡æ¯ï¼‰"""
    # ... ç°æœ‰é€»è¾‘ ...

    for data in raw_messages:
        # ... è§£æé€»è¾‘ ...

        if msg_type == "user":
            input_context = detect_user_input_type(data)

            messages.append({
                "role": "user",
                "content": content_blocks,
                "timestamp": data.get("timestamp"),
                "uuid": data.get("uuid"),
                "parentUuid": data.get("parentUuid"),
                # æ–°å¢ï¼šè¾“å…¥ç±»å‹ä¿¡æ¯
                "input_type": input_context.input_type.value,
                "has_context": input_context.has_context,
                "raw_text": input_context.raw_text,
            })

    return {
        "session_id": session_id,
        "project_path": project_path or "",
        "messages": messages,
    }
```

### 9.3 è½®æ¬¡åˆ¤æ–­å®ç°

#### è½®æ¬¡ç±»å‹æšä¸¾

```python
from enum import Enum

class RoundType(Enum):
    """å¯¹è¯è½®æ¬¡ç±»å‹"""
    NEW_SESSION = "new_session"     # å…¨æ–°ä¼šè¯
    CONTINUE = "continue"            # ç»§ç»­å½“å‰å¯¹è¯
    NEW_ROUND = "new_round"         # æ–°çš„ä¸€è½®å¯¹è¯
    RESUME = "resume"               # ä»å†å²ä¼šè¯æ¢å¤
```

#### è½®æ¬¡åˆ¤æ–­ç®—æ³•

```python
from datetime import datetime

def determine_round_type(
    current_msg: dict,
    prev_msg: dict | None = None,
    threshold_minutes: int = 5
) -> RoundType:
    """
    åˆ¤æ–­å½“å‰ç”¨æˆ·æ¶ˆæ¯å±äºå“ªä¸€è½®

    åˆ¤æ–­ä¼˜å…ˆçº§ï¼š
    1. permissionMode å­˜åœ¨ â†’ æ–°ä¼šè¯ï¼ˆæœ€å¯é ï¼‰
    2. parentUuid ä¸º null â†’ æ–°ä¼šè¯
    3. å†…å®¹åŒ…å« tool_result â†’ ç»§ç»­å½“å‰å¯¹è¯
    4. æ—¶é—´é—´éš” > é˜ˆå€¼ â†’ ä¼šè¯æ¢å¤

    Args:
        current_msg: å½“å‰ç”¨æˆ·æ¶ˆæ¯
        prev_msg: å‰ä¸€æ¡æ¶ˆæ¯
        threshold_minutes: æ—¶é—´é—´éš”é˜ˆå€¼ï¼ˆåˆ†é’Ÿï¼‰

    Returns:
        RoundType: è½®æ¬¡ç±»å‹
    """
    # 1. permissionMode å­˜åœ¨ = æ–°ä¼šè¯ï¼ˆæœ€å¯é ï¼‰
    if current_msg.get("permissionMode") is not None:
        return RoundType.NEW_SESSION

    # 2. parentUuid ä¸º null = æ–°ä¼šè¯
    if current_msg.get("parentUuid") is None:
        return RoundType.NEW_SESSION

    # 3. æ£€æŸ¥å†…å®¹ç±»å‹ - tool_result = ç»§ç»­
    input_type = current_msg.get("input_type", "")
    if input_type == "tool_result":
        return RoundType.CONTINUE

    # 4. æ—¶é—´é—´éš”åˆ¤æ–­
    if prev_msg:
        prev_time = prev_msg.get("timestamp", "")
        curr_time = current_msg.get("timestamp", "")

        if prev_time and curr_time:
            try:
                prev_dt = datetime.fromisoformat(prev_time.replace("Z", "+00:00"))
                curr_dt = datetime.fromisoformat(curr_time.replace("Z", "+00:00"))
                gap_minutes = (curr_dt - prev_dt).total_seconds() / 60

                if gap_minutes > threshold_minutes:
                    return RoundType.RESUME
            except (ValueError, TypeError):
                pass

    return RoundType.NEW_ROUND
```

#### å‰ç«¯è½®æ¬¡å¤„ç†

```javascript
class MessageRenderer {
    // ... ç°æœ‰æ–¹æ³• ...

    /**
     * ä¸ºæ¶ˆæ¯æ·»åŠ è½®æ¬¡ä¿¡æ¯
     */
    enrichMessagesWithRounds(messages) {
        const enriched = [];
        let currentRoundIndex = 0;

        for (let i = 0; i < messages.length; i++) {
            const msg = { ...messages[i] };
            const prevMsg = i > 0 ? messages[i - 1] : null;

            if (msg.role === 'user') {
                const roundType = this.determineRoundType(msg, prevMsg);
                msg.roundType = roundType;

                // ä¸ºæ–°è½®æ¬¡æ·»åŠ æ ‡è®°
                if (roundType === 'new_session' || roundType === 'new_round' || roundType === 'resume') {
                    currentRoundIndex++;
                    msg.isRoundStart = true;
                    msg.roundIndex = currentRoundIndex;
                }
            }

            enriched.push(msg);
        }

        return enriched;
    }

    /**
     * åˆ¤æ–­è½®æ¬¡ç±»å‹ï¼ˆå‰ç«¯ç‰ˆï¼‰
     *
     * åˆ¤æ–­ä¼˜å…ˆçº§ï¼š
     * 1. permissionMode å­˜åœ¨ â†’ æ–°ä¼šè¯ï¼ˆæœ€å¯é ï¼‰
     * 2. parentUuid ä¸º null â†’ æ–°ä¼šè¯
     * 3. input_type === 'tool_result' â†’ ç»§ç»­
     * 4. æ—¶é—´é—´éš”å¤§ â†’ æ¢å¤
     */
    determineRoundType(currentMsg, prevMsg) {
        // 1. permissionMode å­˜åœ¨ = æ–°ä¼šè¯ï¼ˆæœ€å¯é ï¼‰
        if (currentMsg.permissionMode) {
            return 'new_session';
        }

        // 2. parentUuid ä¸º null = æ–°ä¼šè¯
        if (!currentMsg.parentUuid) {
            return 'new_session';
        }

        // 3. å·¥å…·ç»“æœ = ç»§ç»­
        if (currentMsg.input_type === 'tool_result') {
            return 'continue';
        }

        // 4. æ—¶é—´é—´éš”åˆ¤æ–­
        if (prevMsg && currentMsg.timestamp && prevMsg.timestamp) {
            const gap = this.getTimeGapMinutes(currentMsg.timestamp, prevMsg.timestamp);
            if (gap > 5) {
                return 'resume';
            }
        }

        return 'new_round';
    }

    /**
     * è®¡ç®—æ—¶é—´é—´éš”ï¼ˆåˆ†é’Ÿï¼‰
     */
    getTimeGapMinutes(time1, time2) {
        const date1 = new Date(time1);
        const date2 = new Date(time2);
        return Math.abs(date1 - date2) / (1000 * 60);
    }

    /**
     * æ ¹æ®è½®æ¬¡ç±»å‹æ¸²æŸ“ç”¨æˆ·æ¶ˆæ¯
     */
    renderUserContent(message) {
        const inputType = message.input_type;
        const roundType = message.roundType;

        // æ·»åŠ è½®æ¬¡æ ‡è¯†
        let roundBadge = '';
        if (message.isRoundStart) {
            const roundLabels = {
                'new_session': 'ğŸ†• æ–°ä¼šè¯',
                'new_round': 'ğŸ”„ æ–°è½®æ¬¡',
                'resume': 'â¸ï¸ ç»§ç»­',
            };
            roundBadge = `<span class="round-badge">${roundLabels[roundType] || ''}</span>`;
        }

        // æ ¹æ®è¾“å…¥ç±»å‹é€‰æ‹©æ¸²æŸ“æ–¹å¼
        let contentHtml = '';
        if (inputType === 'ide_selection') {
            contentHtml = this.renderIdeSelection(message.content);
        } else if (inputType === 'ide_opened_file') {
            contentHtml = this.renderIdeOpenedFile(message.content);
        } else {
            contentHtml = this.renderDefaultContent(message.content);
        }

        return roundBadge + contentHtml;
    }

    /**
     * æ¸²æŸ“ IDE é€‰ä¸­å†…å®¹
     */
    renderIdeSelection(content) {
        // æå– IDE ä¸Šä¸‹æ–‡å’Œå®é™…æ–‡æœ¬
        const ideContext = this.extractIdeContext(content, 'ide_selection');
        const userText = this.extractUserText(content);

        return `
            <div class="ide-context ide-selection">
                <span class="context-label">ğŸ“Œ é€‰ä¸­ä»£ç </span>
                <pre class="context-code">${this.escapeHtml(ideContext)}</pre>
            </div>
            <div class="user-text">${this.escapeHtml(userText)}</div>
        `;
    }

    /**
     * æ¸²æŸ“ IDE æ‰“å¼€æ–‡ä»¶å†…å®¹
     */
    renderIdeOpenedFile(content) {
        const ideContext = this.extractIdeContext(content, 'ide_opened_file');
        const userText = this.extractUserText(content);

        return `
            <div class="ide-context ide-opened-file">
                <span class="context-label">ğŸ“‚ å·²æ‰“å¼€æ–‡ä»¶</span>
                <span class="context-path">${this.escapeHtml(ideContext)}</span>
            </div>
            <div class="user-text">${this.escapeHtml(userText)}</div>
        `;
    }

    /**
     * æå– IDE ä¸Šä¸‹æ–‡
     */
    extractIdeContext(content, contextType) {
        for (const block of content) {
            if (block.type === 'text' && block.text) {
                const match = block.text.match(/<ide_selection>([\s\S]*?)<\/ide_selection>/);
                if (match) return match[1].trim();

                const match2 = block.text.match(/<ide_opened_file>([\s\S]*?)<\/ide_opened_file>/);
                if (match2) return match2[1].trim();
            }
        }
        return '';
    }

    /**
     * æå–ç”¨æˆ·å®é™…æ–‡æœ¬ï¼ˆå»é™¤ IDE æ ‡ç­¾ï¼‰
     */
    extractUserText(content) {
        const parts = [];
        for (const block of content) {
            if (block.type === 'text' && block.text) {
                let text = block.text
                    .replace(/<ide_selection>[\s\S]*?<\/ide_selection>/g, '')
                    .replace(/<ide_opened_file>[\s\S]*?<\/ide_opened_file>/g, '')
                    .trim();
                if (text) {
                    parts.push(text);
                }
            }
        }
        return parts.join(' ');
    }
}
```

### 9.4 CSS æ ·å¼æ‰©å±•

```css
/* è½®æ¬¡æ ‡è¯†æ ·å¼ */
.round-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 500;
    margin-right: 8px;
    background: rgba(99, 102, 241, 0.1);
    color: #6366f1;
}

.round-badge.new-session {
    background: rgba(16, 185, 129, 0.1);
    color: #10b981;
}

.round-badge.resume {
    background: rgba(251, 191, 36, 0.1);
    color: #d97706;
}

/* IDE ä¸Šä¸‹æ–‡æ ·å¼ */
.ide-context {
    padding: 8px 12px;
    border-radius: 6px;
    margin-bottom: 8px;
    font-size: 0.85rem;
}

.ide-selection {
    background: rgba(99, 102, 241, 0.1);
    border-left: 3px solid #6366f1;
}

.ide-opened-file {
    background: rgba(251, 191, 36, 0.1);
    border-left: 3px solid #fbbf24;
}

.context-label {
    display: block;
    font-weight: 500;
    margin-bottom: 4px;
    color: var(--text-muted);
}

.context-code,
.context-path {
    display: block;
    font-family: monospace;
    font-size: 0.8rem;
    white-space: pre-wrap;
    word-break: break-all;
}

/* ç”¨æˆ·æ–‡æœ¬æ ·å¼ */
.user-text {
    line-height: 1.6;
}
```

### 9.5 æµ‹è¯•ç”¨ä¾‹

```python
class TestUserInputTypeDetection:
    """ç”¨æˆ·è¾“å…¥ç±»å‹æ£€æµ‹æµ‹è¯•"""

    def test_ide_selection(self):
        """æµ‹è¯• IDE é€‰ä¸­ç±»å‹æ£€æµ‹"""
        message = {
            "message": {
                "content": [
                    {
                        "type": "text",
                        "text": "<ide_selection>é€‰ä¸­çš„ä»£ç </ide_selection>å¸®æˆ‘å®ç°è¿™ä¸ªåŠŸèƒ½"
                    }
                ]
            }
        }
        result = detect_user_input_type(message)
        assert result.input_type == UserInputType.IDE_SELECTION
        assert result.has_context is True

    def test_ide_opened_file(self):
        """æµ‹è¯• IDE æ‰“å¼€æ–‡ä»¶ç±»å‹æ£€æµ‹"""
        message = {
            "message": {
                "content": [
                    {
                        "type": "text",
                        "text": "<ide_opened_file>æ‰“å¼€çš„æ–‡ä»¶è·¯å¾„</ide_opened_file>ç»§ç»­"
                    }
                ]
            }
        }
        result = detect_user_input_type(message)
        assert result.input_type == UserInputType.IDE_OPENED_FILE
        assert result.has_context is True

    def test_tool_result(self):
        """æµ‹è¯•å·¥å…·ç»“æœç±»å‹æ£€æµ‹"""
        message = {
            "message": {
                "content": [
                    {
                        "type": "tool_result",
                        "tool_use_id": "call_xxx",
                        "content": "å·¥å…·è¿”å›å†…å®¹"
                    }
                ]
            }
        }
        result = detect_user_input_type(message)
        assert result.input_type == UserInputType.TOOL_RESULT

    def test_plain_text(self):
        """æµ‹è¯•æ™®é€šæ–‡æœ¬ç±»å‹æ£€æµ‹"""
        message = {
            "message": {
                "content": [
                    {
                        "type": "text",
                        "text": "è¿™æ˜¯ä¸€ä¸ªæ™®é€šæ–‡æœ¬è¾“å…¥"
                    }
                ]
            }
        }
        result = detect_user_input_type(message)
        assert result.input_type == UserInputType.PLAIN_TEXT
        assert result.has_context is False


class TestRoundTypeDetermination:
    """è½®æ¬¡ç±»å‹åˆ¤æ–­æµ‹è¯•"""

    def test_new_session_by_permission_mode(self):
        """æµ‹è¯• permissionMode å­˜åœ¨ = æ–°ä¼šè¯ï¼ˆæœ€å¯é ï¼‰"""
        current = {"permissionMode": "acceptEdits"}
        result = determine_round_type(current, None)
        assert result == RoundType.NEW_SESSION

    def test_new_session_by_parent_uuid(self):
        """æµ‹è¯• parentUuid ä¸º null = æ–°ä¼šè¯"""
        current = {"parentUuid": None}
        result = determine_round_type(current, None)
        assert result == RoundType.NEW_SESSION

    def test_ide_selection_is_new_session(self):
        """æµ‹è¯• IDE é€‰ä¸­å±äºæ–°ä¼šè¯ï¼ˆå·²è¢« permissionMode æ›¿ä»£ï¼‰"""
        current = {
            "parentUuid": "prev-uuid",
            "input_type": "ide_selection"
        }
        result = determine_round_type(current, {})
        # ç”±äº permissionMode ä¸å­˜åœ¨ï¼Œä¼šè¢«åˆ¤æ–­ä¸º new_round
        # è¿™ä¸ªæµ‹è¯•ä¿ç•™ä»¥è¯´æ˜æ—§çš„åˆ¤æ–­é€»è¾‘
        assert result in [RoundType.NEW_SESSION, RoundType.NEW_ROUND]

    def test_tool_result_is_continue(self):
        """æµ‹è¯•å·¥å…·ç»“æœå±äºç»§ç»­"""
        current = {
            "parentUuid": "prev-uuid",
            "input_type": "tool_result"
        }
        result = determine_round_type(current, {})
        assert result == RoundType.CONTINUE

    def test_large_time_gap_is_resume(self):
        """æµ‹è¯•æ—¶é—´é—´éš”å¤§å±äºæ¢å¤"""
        import datetime
        now = datetime.datetime.now(datetime.timezone.utc)

        current = {
            "parentUuid": "prev-uuid",
            "input_type": "plain_text",
            "timestamp": now.isoformat()
        }

        # 10 åˆ†é’Ÿå‰
        past = now - datetime.timedelta(minutes=10)
        prev = {
            "timestamp": past.isoformat()
        }

        result = determine_round_type(current, prev, threshold_minutes=5)
        assert result == RoundType.RESUME
```


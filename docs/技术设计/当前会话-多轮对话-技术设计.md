# 当前会话 - 多轮对话技术设计

## 1. 概述

本文档详细描述多轮对话功能的通用技术设计方案，包括系统架构、数据结构、交互流程、状态管理等核心技术实现细节，为具体的多轮对话实现场景提供统一的技术框架。

## 2. 系统架构设计

### 2.1 整体架构图
```
[用户界面] ↔ [消息渲染器] ↔ [任务管理器] ↔ [对话执行引擎]
     ↑              ↑              ↑              ↑
[对话框组件]    [SSE流处理]    [状态管理]    [AI模型交互]
```

### 2.2 核心组件职责

#### 2.2.1 前端组件
- **DialogManager**: 对话框管理器，负责UI组件的创建和销毁
- **MessageRenderer**: 消息渲染引擎，处理SSE流数据
- **TaskManager**: 任务状态协调器，管理会话生命周期
- **StateTracker**: 状态跟踪器，维护对话状态

#### 2.2.2 后端服务
- **DialogEngine**: 对话执行引擎，处理多轮对话逻辑
- **SessionManager**: 会话状态管理，维护对话上下文
- **ConcurrencyManager**: 并发控制管理器，限制同时进行的对话数量
- **InputValidator**: 输入验证器，确保用户输入安全
- **WebSocket/SSE**: 实时通信通道，推送对话状态

## 3. 数据结构设计

### 3.1 核心数据模型

#### 3.1.1 通用对话数据结构
```python
@dataclass
class DialogBase:
    """通用对话基类"""
    dialog_id: str
    dialog_type: str  # 具体对话类型，如 "ask_user_question", "permission_confirmation"
    session_id: str
    status: DialogStatus
    timeout_seconds: int = 300
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)

@dataclass  
class DialogOption:
    """对话选项定义"""
    id: str
    label: str
    description: Optional[str] = None
    default: bool = False

@dataclass
class FollowUpDialog:
    """后续对话定义"""
    dialog_id: str
    dialog_text: str
    dialog_type: str
    options: Optional[list[DialogOption]] = None
```

#### 3.1.2 状态枚举
```python
class DialogStatus(Enum):
    PENDING = "pending"      # 等待显示
    SHOWING = "showing"      # 正在显示  
    ANSWERED = "answered"    # 已回答
    PROCESSING = "processing" # 处理中
    COMPLETED = "completed"  # 已完成
    ERROR = "error"          # 错误
    TIMEOUT = "timeout"      # 超时
```

### 3.2 消息格式规范

#### 3.2.1 SSE消息格式
```json
{
  "type": "dialog_request",
  "content": "对话内容",
  "dialog": {
    "dialog_id": "唯一标识符",
    "dialog_type": "对话类型",
    "dialog_text": "对话文本",
    "options": [...],
    "status": "pending"
  },
  "session_id": "会话ID"
}
```

#### 3.2.2 REST API响应格式
```json
{
  "success": true,
  "message": "操作结果描述",
  "dialog_id": "对话ID",
  "status": "当前状态"
}
```

## 4. 交互流程设计

### 4.1 通用对话流程
```
1. AI模型发起对话请求
2. 后端创建对话实例，设置状态为PENDING
3. 通过SSE发送对话消息给前端
4. 前端显示对话框，状态更新为SHOWING
5. 用户提交答案
6. 前端调用REST API提交答案
7. 后端验证答案，更新状态为ANSWERED
8. 后端处理答案，构建响应给AI模型
9. 状态更新为COMPLETED或ERROR
10. 前端关闭对话框
```

### 4.2 并发控制流程
```
1. 新对话请求到达
2. 检查当前活跃对话数量
3. 如果未达到最大并发限制：
   - 直接处理对话
4. 如果达到最大并发限制：
   - 将对话加入等待队列
   - 等待有对话完成后再处理
```

### 4.3 超时处理流程
```
1. 对话创建时启动超时计时器
2. 如果在超时时间内收到用户答案：
   - 正常处理答案
3. 如果超时时间到达仍未收到答案：
   - 自动关闭对话
   - 状态更新为TIMEOUT
   - 通知AI模型对话超时
```

## 5. 状态管理机制

### 5.1 状态转换图
```
PENDING → SHOWING → ANSWERED → PROCESSING → COMPLETED
                             ↘
                              → ERROR
                             ↘  
                              → TIMEOUT
```

### 5.2 状态持久化
- 对话状态必须在内存中维护
- 关键状态变更必须记录日志
- 支持会话恢复和状态重建

## 6. 安全设计

### 6.1 输入验证
- 所有用户输入必须经过安全清理
- 限制输入长度和字符集
- 防止XSS和注入攻击

### 6.2 权限控制
- 对话操作必须验证会话有效性
- 防止跨会话操作
- 支持权限模式配置

### 6.3 日志审计
- 记录所有对话创建和状态变更
- 记录用户答案提交
- 支持问题追踪和调试

## 7. 性能考虑

### 7.1 资源管理
- 限制最大并发对话数（默认5个）
- 及时清理已完成的对话实例
- 监控内存使用情况

### 7.2 响应时间
- SSE消息推送延迟 < 100ms
- REST API响应时间 < 500ms
- 对话状态更新实时性

## 8. 扩展性设计

### 8.1 插件架构
- 支持自定义对话类型
- 可扩展的验证规则
- 灵活的消息格式

### 8.2 配置管理
- 可配置的最大并发数
- 可配置的超时时间
- 可配置的安全策略

## 9. 具体实现场景

具体的多轮对话实现场景（如AskUserQuestion）应继承并遵循本通用技术设计，并可根据具体需求进行适当扩展。

## 10. 相关文档

- `当前会话-多轮对话-需求.md`：业务需求规范
- `当前会话-多轮对话-AskUserQuestion-技术设计.md`：AskUserQuestion具体实现技术设计